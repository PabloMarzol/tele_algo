import logging
import asyncio
import os
import signal
import csv
from typing import Tuple
from datetime import datetime
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.cron import CronTrigger
from ga_integration import MultiGiveawayIntegration, setup_multi_giveaway_files, verify_multi_giveaway_configuration
from config_loader import ConfigLoader
from async_manager import prevent_concurrent_callback, setup_async_safety
from admin_permissions import AdminPermissionManager, SystemAction, PermissionGroup, setup_permission_system, get_permission_manager, require_permission, require_any_permission, require_draw_permission_with_time_check

# üÜï NUEVOS IMPORTS - SISTEMA DE PERMISOS
from admin_permissions import (
    AdminPermissionManager, 
    SystemAction, 
    PermissionGroup,
    setup_permission_system,
    get_permission_manager,
    require_permission,
    require_any_permission,
    require_draw_permission_with_time_check
)

# ==================== MULTI-TYPE GIVEAWAY BOT ====================

class RealMT5API:
    """
    üîÑ MODIFIED: Enhanced MT5 API for multi-type system
    Replace this with your real MT5 implementation
    """
    
    def get_account_info(self, account_number):
        """
        REPLACE WITH YOUR REAL MT5 API
        
        Should return:
        {
            'exists': True,
            'is_live': True,
            'balance': 150.50,
            'currency': 'USD'
        }
        or None if account doesn't exist
        """
        
        try:
            # üß™ ENHANCED SIMULATION - Remove in production
            test_accounts = {
                # ‚úÖ VALID ACCOUNTS FOR PARTICIPATION (LIVE + Balance >= $100)
                '1234': {'exists': True, 'is_live': True, 'balance': 150.50, 'currency': 'USD'},
                '8765': {'exists': True, 'is_live': True, 'balance': 250.75, 'currency': 'USD'},
                '3333': {'exists': True, 'is_live': True, 'balance': 300.00, 'currency': 'USD'},
                '4444': {'exists': True, 'is_live': True, 'balance': 125.25, 'currency': 'USD'},
                '5555': {'exists': True, 'is_live': True, 'balance': 500.00, 'currency': 'USD'},
                '6666': {'exists': True, 'is_live': True, 'balance': 199.99, 'currency': 'USD'},
                '7777': {'exists': True, 'is_live': True, 'balance': 1000.00, 'currency': 'USD'},
                '8888': {'exists': True, 'is_live': True, 'balance': 750.50, 'currency': 'USD'},
                '1010': {'exists': True, 'is_live': True, 'balance': 100.00, 'currency': 'USD'},
                '2020': {'exists': True, 'is_live': True, 'balance': 100.01, 'currency': 'USD'},
                
                # ‚ùå INSUFFICIENT BALANCE (< $100)
                '2222': {'exists': True, 'is_live': True, 'balance': 50.00, 'currency': 'USD'},
                '3030': {'exists': True, 'is_live': True, 'balance': 99.99, 'currency': 'USD'},
                '4040': {'exists': True, 'is_live': True, 'balance': 25.50, 'currency': 'USD'},
                '5050': {'exists': True, 'is_live': True, 'balance': 0.00, 'currency': 'USD'},
                
                # ‚ùå DEMO ACCOUNTS (Not valid for giveaway)
                '1111': {'exists': True, 'is_live': False, 'balance': 200.00, 'currency': 'USD'},
                '6060': {'exists': True, 'is_live': False, 'balance': 500.00, 'currency': 'USD'},
                '7070': {'exists': True, 'is_live': False, 'balance': 1000.00, 'currency': 'USD'},
                
                # ‚ùå NON-EXISTENT ACCOUNTS
                '9999': None,
                '0000': None,
                '9876': None,
                '1357': None,
                
                # üß™ SPECIAL TESTING ACCOUNTS
                '8080': {'exists': True, 'is_live': True, 'balance': 100.50, 'currency': 'USD'},
                '9090': {'exists': True, 'is_live': True, 'balance': 200.25, 'currency': 'USD'},
            }
            
            result = test_accounts.get(account_number)
            if result is None:
                return None
                
            return {
                'exists': result['exists'],
                'is_live': result['is_live'], 
                'balance': result['balance'],
                'currency': result['currency']
            }
            
        except Exception as e:
            logging.error(f"Error querying MT5 API: {e}")
            return None

# =================== BOT COMMANDS CON PERMISOS ====================

# üÜï RATE LIMITING SIMPLE
user_last_action = {}
RATE_LIMIT_SECONDS = 3

# # ================== COMANDOS BASICOS   ==========================
def is_user_rate_limited(user_id):
    """Simple rate limiting"""
    import time
    current_time = time.time()
    last_action = user_last_action.get(user_id, 0)
    
    if current_time - last_action < RATE_LIMIT_SECONDS:
        return True
    
    user_last_action[user_id] = current_time
    return False

async def start_command(update, context):
    """üîÑ MANTENER IGUAL - Esta funci√≥n no necesita permisos"""
    # Tu c√≥digo existente sin cambios
    global multi_giveaway_integration
        # multi_giveaway_integration
    
    user = update.effective_user

    if is_user_rate_limited(user.id):
        await update.message.reply_text("‚è≥ Please wait a moment before trying again.")
        return

    chat_type = update.effective_chat.type
    args = context.args
    message_text = update.message.text if update.message else ""
    
    if chat_type == 'private':
        # üÜï NEW: Detect giveaway type from participation URL
        participation_type = None
        is_participation = False
        
        if args and len(args) > 0:
            arg = args[0]
            if arg == 'participate':
                # Legacy format - default to daily
                participation_type = 'daily'
                is_participation = True
            elif arg.startswith('participate_'):
                # New format: participate_daily, participate_weekly, participate_monthly
                giveaway_type = arg.replace('participate_', '')
                if giveaway_type in ['daily', 'weekly', 'monthly']:
                    participation_type = giveaway_type
                    is_participation = True
        elif 'participate' in message_text:
            # Fallback detection
            participation_type = 'daily'
            is_participation = True
        
        if is_participation and participation_type:
            # ‚úÖ DIRECT PARTICIPATION FOR SPECIFIC TYPE
            # ‚úÖ DIRECT PARTICIPATION FOR SPECIFIC TYPE
            print(f"üéØ User {user.first_name} wants to participate in {participation_type} giveaway")
            
            # Get the specific giveaway system
            giveaway_system = multi_giveaway_integration.get_giveaway_system(participation_type)
            
            if not giveaway_system:
                await update.message.reply_text(
                    f"‚ùå <b>{participation_type.title()} giveaway not available</b>\n\nPlease try again later.",
                    parse_mode='HTML'
                )
                return
            
            # üîç DEBUG: Verificar directorio de datos
            file_paths = giveaway_system.get_file_paths(participation_type)
            print(f"üîç DEBUG: Expected participants file: {file_paths['participants']}")
            
            # üÜï VERIFICACI√ìN 1: Check if already registered TODAY
            print(f"üîç DEBUG: Checking existing registration for user {user.id}")
            if giveaway_system._is_already_registered(user.id, participation_type):
                prize = giveaway_system.get_prize_amount(participation_type)
                await update.message.reply_text(
                    f"‚ÑπÔ∏è <b>Already registered for {participation_type}</b>\n\nYou are already participating in today's {participation_type} giveaway (${prize}).\n\nüçÄ Good luck in the draw!\n\n‚è∞ Draw: Check schedule",
                    parse_mode='HTML'
                )
                print(f"‚úÖ DEBUG: User {user.id} already registered for {participation_type}")
                return
            
            # üÜï VERIFICACI√ìN 2: Check if participation window is open
            if not giveaway_system.is_participation_window_open(participation_type):
                window_status = giveaway_system.get_participation_window_status(participation_type)
                next_window = window_status.get('next_open', 'Soon')
                
                await update.message.reply_text(
                    f"‚è∞ <b>{participation_type.title()} participation closed</b>\n\nParticipation window is currently closed.\n\nüîÑ <b>Next window opens:</b>\n{next_window}\n\nüí° Stay tuned for the next opportunity!",
                    parse_mode='HTML'
                )
                return
            
            # üÜï VERIFICACI√ìN 3: Check if has pending registration for this type
            if context.user_data.get(f'awaiting_mt5_{participation_type}'):
                await update.message.reply_text(
                    f"‚è≥ <b>{participation_type.title()} registration in progress</b>\n\nYou already have a {participation_type} registration pending.\n\nPlease send your MT5 account number to complete your participation.",
                    parse_mode='HTML'
                )
                return
            
            # üÜï VERIFICACI√ìN 4: Check channel membership
            try:
                config_loader = ConfigLoader()
                bot_config = config_loader.get_bot_config()
                channel_id = bot_config['channel_id']
                
                member = await context.bot.get_chat_member(channel_id, user.id)
                is_member = member.status in ['member', 'administrator', 'creator']
            except Exception as e:
                print(f"‚ùå DEBUG: Error checking membership: {e}")
                is_member = False
            
            if not is_member:
                await update.message.reply_text(
                    "‚ùå <b>Not a channel member</b>\n\nYou must be a member of the main channel to participate.\n\nüí° Join the channel and try again.",
                    parse_mode='HTML'
                )
                return
            
            # ‚úÖ ALL CHECKS PASSED - REQUEST MT5 ACCOUNT
            prize = giveaway_system.get_prize_amount(participation_type)
            
            await update.message.reply_text(
                f"üéÅ <b>Perfect {user.first_name}!</b>\n\n‚úÖ You are a channel member\n‚úÖ Ready to participate in {participation_type.upper()} giveaway\n\nüí∞ <b>Prize:</b> ${prize} USD\n\nüî¢ <b>Send your MT5 account number:</b>\n\nüí° <b>Valid examples:</b>\n‚Ä¢ 1234, 4444, 5555, 7777\n‚Ä¢ 8765, 3333, 6666, 8888\n\n‚ö†Ô∏è <b>Only numbers, no spaces</b>",
                parse_mode='HTML'
            )
            
            # Activate waiting state for this specific type
            context.user_data[f'awaiting_mt5_{participation_type}'] = True
            context.user_data[f'mt5_attempts_{participation_type}'] = 0 
            context.user_data[f'user_info_{participation_type}'] = {
                'id': user.id,
                'username': user.username,
                'first_name': user.first_name,
                'giveaway_type': participation_type
            }
            print(f"‚úÖ DEBUG: User {user.id} activated for {participation_type} registration")
            print(f"‚úÖ DEBUG: awaiting_mt5_{participation_type} = {context.user_data.get(f'awaiting_mt5_{participation_type}')}")
            
        else:
            # ‚úÖ NORMAL /start - WELCOME MESSAGE WITH TYPE SELECTION
            bot_info = await context.bot.get_me()
            bot_username = bot_info.username
            
            message = f"""üéÅ <b>Hello {user.first_name}!</b>

Welcome to the VFX Trading Multi-Giveaway Bot.

üåü <b>AVAILABLE GIVEAWAYS:</b>

üí∞ <b>DAILY:</b> $250 USD
‚è∞ Monday to Friday at 5:00 PM London Time

üí∞ <b>WEEKLY:</b> $500 USD  
‚è∞ Every Friday at 5:15 PM London Time

üí∞ <b>MONTHLY:</b> $1000 USD
‚è∞ Last Friday of each month at 5:30 PM London Time

üìã <b>Requirements for all:</b>
‚úÖ Active MT5 LIVE account
‚úÖ Minimum balance $100 USD  
‚úÖ Be a channel member

üéØ <b>Choose which giveaway to participate in:</b>"""
            
            # Create participation buttons for each type
            buttons = []
            
            for giveaway_type in ['daily', 'weekly', 'monthly']:
                giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                
                # Check if window is open
                is_open = giveaway_system.is_participation_window_open(giveaway_type)
                status_emoji = "üü¢" if is_open else "üî¥"
                
                button_text = f"{status_emoji} {giveaway_type.title()} (${prize})"
                participate_link = f"https://t.me/{bot_username}?start=participate_{giveaway_type}"
                buttons.append([InlineKeyboardButton(button_text, url=participate_link)])
            
            # Add info button
            buttons.append([InlineKeyboardButton("üìã View Rules & Schedule", callback_data="show_rules")])
            
            reply_markup = InlineKeyboardMarkup(buttons)
            
            await update.message.reply_text(
                message, 
                parse_mode='HTML',
                reply_markup=reply_markup
            )
            
            print(f"‚úÖ Multi-type welcome message sent to {user.first_name}")
            
    else:
        # Message for group/channel
        await update.message.reply_text(
            "üéÅ <b>VFX Trading Multi-Giveaway Bot</b>\n\nTo participate in any giveaway, send me a private message with /start",
            parse_mode='HTML'
        )

async def help_command(update, context):
    """üîÑ MANTENER IGUAL - No necesita permisos espec√≠ficos"""
    
    try:
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        admin_username = bot_config.get('admin_username', 'admin')
    except:
        admin_username = 'admin'
    
    help_text = f"""üÜò <b>MULTI-GIVEAWAY RULES</b>

üåü <b>AVAILABLE GIVEAWAYS:</b>

üí∞ <b>DAILY GIVEAWAY - $250 USD</b>
‚è∞ <b>Participation:</b> Monday-Friday, 1:00 AM - 4:50 PM London Time
üéØ <b>Draw:</b> Monday-Friday at 5:00 PM London Time
üîÑ <b>Cooldown:</b> 30 days after winning

üí∞ <b>WEEKLY GIVEAWAY - $500 USD</b>
‚è∞ <b>Participation:</b> Monday 9:00 AM - Friday 5:00 PM London Time
üéØ <b>Draw:</b> Friday at 5:15 PM London Time
üîÑ <b>Cooldown:</b> 60 days after winning

üí∞ <b>MONTHLY GIVEAWAY - $1000 USD</b>
‚è∞ <b>Participation:</b> Day 1 - Last Friday of month, London Time
üéØ <b>Draw:</b> Last Friday at 5:30 PM London Time
üîÑ <b>Cooldown:</b> 90 days after winning

üìã <b>REQUIREMENTS FOR ALL GIVEAWAYS:</b>
‚úÖ Be a member of this channel
‚úÖ Active MT5 LIVE account (not demo)
‚úÖ Minimum balance of $100 USD
‚úÖ One participation per giveaway type per period

üîí <b>IMPORTANT RULES:</b>
‚Ä¢ Each MT5 account belongs to the first user who registers it
‚Ä¢ You can participate in ALL giveaway types simultaneously
‚Ä¢ Independent cooldowns for each giveaway type
‚Ä¢ Must confirm receipt of prize if you win

‚ùå <b>COMMON ERRORS:</b>
‚Ä¢ "Account not found" ‚Üí Verify the number
‚Ä¢ "Insufficient balance" ‚Üí Deposit more than $100 USD
‚Ä¢ "Account is not LIVE" ‚Üí Use real account, not demo
‚Ä¢ "Already registered" ‚Üí Only one participation per type per period
‚Ä¢ "Account belongs to another" ‚Üí Use your own MT5 account

üìû <b>NEED HELP?</b>
Contact administrator: @{admin_username}

‚è∞ <b>CURRENT LONDON TIME:</b>
{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC

üéØ <b>Use /start to participate in any giveaway!</b>"""
    
    await update.message.reply_text(help_text, parse_mode='HTML')

# ==================== COMANDOS ADMIN BASICOS POR TIPO Y CON PERMISOS ====================

# üéØ COMANDOS DE INVITACIONES POR TIPO

@require_permission(SystemAction.SEND_DAILY_INVITATION)
async def admin_send_daily_invitation(update, context):
    """üÜï NUEVO: Enviar invitaci√≥n diaria (CON PERMISOS)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Daily invitation authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('daily')
        success = await giveaway_system.send_invitation('daily')
        
        if success:
            await update.message.reply_text("‚úÖ Daily giveaway invitation sent to channel")
            permission_manager.log_action(user_id, SystemAction.SEND_DAILY_INVITATION, "Daily invitation sent successfully")
        else:
            await update.message.reply_text("‚ùå Error sending daily invitation")
            permission_manager.log_action(user_id, SystemAction.SEND_DAILY_INVITATION, "Failed to send daily invitation")
        
    except Exception as e:
        logging.error(f"Error in daily invitation: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")

@require_permission(SystemAction.SEND_WEEKLY_INVITATION)
async def admin_send_weekly_invitation(update, context):
    """üÜï NUEVO: Enviar invitaci√≥n semanal (CON PERMISOS)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Weekly invitation authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('weekly')
        success = await giveaway_system.send_invitation('weekly')
        
        if success:
            await update.message.reply_text("‚úÖ Weekly giveaway invitation sent to channel")
            permission_manager.log_action(user_id, SystemAction.SEND_WEEKLY_INVITATION, "Weekly invitation sent successfully")
        else:
            await update.message.reply_text("‚ùå Error sending weekly invitation")
            permission_manager.log_action(user_id, SystemAction.SEND_WEEKLY_INVITATION, "Failed to send weekly invitation")
        
    except Exception as e:
        logging.error(f"Error in weekly invitation: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")

@require_permission(SystemAction.SEND_MONTHLY_INVITATION)
async def admin_send_monthly_invitation(update, context):
    """üÜï NUEVO: Enviar invitaci√≥n mensual (CON PERMISOS)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Monthly invitation authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('monthly')
        success = await giveaway_system.send_invitation('monthly')
        
        if success:
            await update.message.reply_text("‚úÖ Monthly giveaway invitation sent to channel")
            permission_manager.log_action(user_id, SystemAction.SEND_MONTHLY_INVITATION, "Monthly invitation sent successfully")
        else:
            await update.message.reply_text("‚ùå Error sending monthly invitation")
            permission_manager.log_action(user_id, SystemAction.SEND_MONTHLY_INVITATION, "Failed to send monthly invitation")
        
    except Exception as e:
        logging.error(f"Error in monthly invitation: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")

# üé≤ COMANDOS DE SORTEOS POR TIPO CON VERIFICACI√ìN HORARIA

@require_draw_permission_with_time_check('daily')
async def admin_run_daily_draw(update, context):
    """üÜï NUEVO: Ejecutar sorteo diario (CON PERMISOS Y VERIFICACI√ìN HORARIA)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)

    # üÜï USAR la nueva funci√≥n de verificaci√≥n
    authorized, message = permission_manager.verify_time_restricted_action(
        user_id, SystemAction.EXECUTE_DAILY_DRAW, 'daily'
    )

    if not authorized:
        await update.message.reply_text(f"‚ùå {message}")
        return
    
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Daily draw authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('daily')
        await giveaway_system.run_giveaway('daily')
        
        # Check results
        pending_winners = giveaway_system.get_pending_winners('daily')
        pending_count = len(pending_winners)
        
        if pending_count > 0:
            winner = pending_winners[0]
            username = winner.get('username', '').strip()
            first_name = winner.get('first_name', 'N/A')
            winner_display = f"@{username}" if username else first_name
            prize = giveaway_system.get_prize_amount('daily')
            
            response_message = f"""‚úÖ <b>Daily draw executed successfully</b>

üéØ <b>Winner selected:</b> {winner_display}
üìä <b>MT5 Account:</b> {winner['mt5_account']}
üí∞ <b>Prize:</b> ${prize} USD
üë§ <b>Executed by:</b> {admin_name}

üí° Winner is pending payment confirmation
üí° Use `/admin_confirm_daily` for payment confirmation"""
            
            await update.message.reply_text(response_message, parse_mode='HTML')
            
            # üÜï NUEVA: Notificar a otros admins con permisos de confirmaci√≥n
            await multi_giveaway_integration.notify_payment_admins_new_winner(context, winner, 'daily', admin_name)
            
            permission_manager.log_action(user_id, SystemAction.EXECUTE_DAILY_DRAW, f"Daily draw executed - Winner: {winner_display}")
        else:
            await update.message.reply_text("‚úÖ Daily draw executed - No eligible participants")
            permission_manager.log_action(user_id, SystemAction.EXECUTE_DAILY_DRAW, "Daily draw executed - No participants")
        
    except Exception as e:
        logging.error(f"Error in daily draw: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")

@require_draw_permission_with_time_check('weekly')
async def admin_run_weekly_draw(update, context):
    """üÜï NUEVO: Ejecutar sorteo semanal (CON PERMISOS Y VERIFICACI√ìN HORARIA)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Weekly draw authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('weekly')
        await giveaway_system.run_giveaway('weekly')
        
        # Check results
        pending_winners = giveaway_system.get_pending_winners('weekly')
        pending_count = len(pending_winners)
        
        if pending_count > 0:
            winner = pending_winners[0]
            username = winner.get('username', '').strip()
            first_name = winner.get('first_name', 'N/A')
            winner_display = f"@{username}" if username else first_name
            prize = giveaway_system.get_prize_amount('weekly')
            
            response_message = f"""‚úÖ <b>Weekly draw executed successfully</b>

üéØ <b>Winner selected:</b> {winner_display}
üìä <b>MT5 Account:</b> {winner['mt5_account']}
üí∞ <b>Prize:</b> ${prize} USD
üë§ <b>Executed by:</b> {admin_name}

üí° Winner is pending payment confirmation
üí° Use `/admin_confirm_weekly` for payment confirmation"""
            
            await update.message.reply_text(response_message, parse_mode='HTML')
            
            # üÜï NUEVA: Notificar a otros admins con permisos de confirmaci√≥n
            await multi_giveaway_integration.notify_payment_admins_new_winner(context, winner, 'weekly', admin_name)
            
            permission_manager.log_action(user_id, SystemAction.EXECUTE_WEEKLY_DRAW, f"Weekly draw executed - Winner: {winner_display}")
        else:
            await update.message.reply_text("‚úÖ Weekly draw executed - No eligible participants")
            permission_manager.log_action(user_id, SystemAction.EXECUTE_WEEKLY_DRAW, "Weekly draw executed - No participants")
        
    except Exception as e:
        logging.error(f"Error in weekly draw: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")

@require_draw_permission_with_time_check('monthly')
async def admin_run_monthly_draw(update, context):
    """üÜï NUEVO: Ejecutar sorteo mensual (CON PERMISOS Y VERIFICACI√ìN HORARIA)"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Monthly draw authorized for: {admin_name} ({user_id})")
    
    try:
        giveaway_system = multi_giveaway_integration.get_giveaway_system('monthly')
        await giveaway_system.run_giveaway('monthly')
        
        # Check results
        pending_winners = giveaway_system.get_pending_winners('monthly')
        pending_count = len(pending_winners)
        
        if pending_count > 0:
            winner = pending_winners[0]
            username = winner.get('username', '').strip()
            first_name = winner.get('first_name', 'N/A')
            winner_display = f"@{username}" if username else first_name
            prize = giveaway_system.get_prize_amount('monthly')
            
            response_message = f"""‚úÖ <b>Monthly draw executed successfully</b>

üéØ <b>Winner selected:</b> {winner_display}
üìä <b>MT5 Account:</b> {winner['mt5_account']}
üí∞ <b>Prize:</b> ${prize} USD
üë§ <b>Executed by:</b> {admin_name}

üí° Winner is pending payment confirmation
üí° Use `/admin_confirm_monthly` for payment confirmation"""
            
            await update.message.reply_text(response_message, parse_mode='HTML')
            
            # üÜï NUEVA: Notificar a otros admins con permisos de confirmaci√≥n
            await multi_giveaway_integration.notify_payment_admins_new_winner(context, winner, 'monthly', admin_name)
            
            permission_manager.log_action(user_id, SystemAction.EXECUTE_MONTHLY_DRAW, f"Monthly draw executed - Winner: {winner_display}")
        else:
            await update.message.reply_text("‚úÖ Monthly draw executed - No eligible participants")
            permission_manager.log_action(user_id, SystemAction.EXECUTE_MONTHLY_DRAW, "Monthly draw executed - No participants")
        
    except Exception as e:
        logging.error(f"Error in monthly draw: {e}")
        await update.message.reply_text(f"‚ùå Error: {e}")



# ====================  COMANDOS UTILIDAD y DEBUG  CON PERMISOS ====================

# @require_permission(SystemAction.VIEW_ADVANCED_STATS)
@require_any_permission(
    SystemAction.VIEW_BASIC_STATS,
    SystemAction.VIEW_ADVANCED_STATS
)
async def stats_command(update, context):
    """üîÑ MODIFICADA: Stats con niveles de permisos"""
    try:
        user_id = update.effective_user.id
        permission_manager = get_permission_manager(context)

        admin_info = permission_manager.get_admin_info(user_id) if permission_manager else None
        admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'

        # üÜï DETERMINAR nivel de acceso
        has_advanced = permission_manager and permission_manager.has_permission(user_id, SystemAction.VIEW_ADVANCED_STATS)
        permission_level = admin_info.get('permission_group', 'Unknown') if admin_info else 'Unknown'

        if has_advanced:
            # Mostrar estad√≠sticas completas (c√≥digo existente)
            combined_stats = multi_giveaway_integration.get_giveaway_stats()
            # ... c√≥digo completo existente ...
        else:
            # üÜï Mostrar solo estad√≠sticas b√°sicas para VIEW_ONLY
            basic_message = f"üìä <b>BASIC STATISTICS</b>\n"
            basic_message += f"üîí <b>Access Level:</b> {permission_level}\n\n"
            
            total_today = 0
            for giveaway_type in ['daily', 'weekly', 'monthly']:
                giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                today_count = stats.get('today_participants', 0)
                total_today += today_count
                
                basic_message += f"üéØ <b>{giveaway_type.upper()} (${prize}):</b> {today_count} today\n"
            
            basic_message += f"\nüìä <b>Total Today:</b> {total_today} participants"
            basic_message += f"\n\nüí° Advanced statistics require PAYMENT_SPECIALIST+ permissions"
            
            await update.message.reply_text(basic_message, parse_mode='HTML')
            return
        
        
        print(f"‚úÖ Stats access authorized for: {admin_name} ({user_id})")
        
        # Get combined stats
        combined_stats = multi_giveaway_integration.get_giveaway_stats()
        
        # Build stats message
        stats_text = f"""üìä <b>MULTI-GIVEAWAY STATISTICS</b>
<i>Accessed by: {admin_name}</i>

üåü <b>COMBINED TOTALS:</b>
‚îú‚îÄ Total participants: <b>{combined_stats['total_participants_all']}</b>
‚îú‚îÄ Total winners: <b>{combined_stats['total_winners_all']}</b>
‚îú‚îÄ Total distributed: <b>${combined_stats['total_distributed_all']}</b>

üìä <b>BY GIVEAWAY TYPE:</b>"""

        for giveaway_type, stats in combined_stats['by_type'].items():
            giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
            prize = giveaway_system.get_prize_amount(giveaway_type)
            pending_count = len(giveaway_system.get_pending_winners(giveaway_type))
            
            stats_text += f"""

üéØ <b>{giveaway_type.upper()} (${prize}):</b>
‚îú‚îÄ Today: {stats.get('today_participants', 0)} participants
‚îú‚îÄ Total: {stats.get('total_participants', 0)} participants  
‚îú‚îÄ Winners: {stats.get('total_winners', 0)}
‚îú‚îÄ Distributed: ${stats.get('total_prize_distributed', 0)}
‚îî‚îÄ Pending: {pending_count}"""

        stats_text += f"\n\nüí° Use specific commands for detailed management"
        
        await update.message.reply_text(stats_text, parse_mode='HTML')
        
        permission_manager.log_action(user_id, SystemAction.VIEW_ADVANCED_STATS, "Advanced stats accessed")
        
    except Exception as e:
        logging.error(f"Error showing stats: {e}")
        await update.message.reply_text("‚ùå Error getting statistics")

@require_permission(SystemAction.HEALTH_CHECK)
async def health_check_command(update, context):
    """üîÑ MODIFICADA: Health check con permisos"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Health check authorized for: {admin_name} ({user_id})")
    
    try:
        # Run comprehensive health check
        health_report = multi_giveaway_integration.verify_all_systems_health()
        
        message = f"""üè• <b>SYSTEM HEALTH CHECK</b>
<i>Requested by: {admin_name}</i>

üå°Ô∏è <b>Overall Status:</b> {health_report['overall_status'].upper()}

üí° <b>System Status:</b>"""

        for giveaway_type, system_status in health_report['systems'].items():
            if system_status['status'] == 'healthy':
                message += f"""
‚úÖ <b>{giveaway_type.upper()}:</b> Operational
‚îú‚îÄ Prize: ${system_status['prize_amount']}
‚îú‚îÄ Pending: {system_status['pending_count']}
‚îî‚îÄ Files: {'‚úÖ' if system_status['files_accessible'] else '‚ùå'}"""
            else:
                message += f"""
‚ùå <b>{giveaway_type.upper()}:</b> Error
‚îî‚îÄ Issue: {system_status.get('error', 'Unknown')}"""

        if health_report.get('issues'):
            message += f"\n\n‚ö†Ô∏è <b>Issues detected:</b>\n"
            for issue in health_report['issues'][:3]:
                message += f"‚Ä¢ {issue}\n"

        message += f"\nüìÖ <b>Checked:</b> {health_report['timestamp']}"
        
        await update.message.reply_text(message, parse_mode='HTML')
        
        permission_manager.log_action(user_id, SystemAction.HEALTH_CHECK, f"Health check completed - Status: {health_report['overall_status']}")
        
    except Exception as e:
        logging.error(f"Error in health check: {e}")
        await update.message.reply_text("‚ùå Error running health check")

@require_permission(SystemAction.MANAGE_ADMINS)
async def admin_security_audit(update, context):
    """üÜï NEW: Auditor√≠a completa de seguridad del sistema"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    
    if not permission_manager:
        await update.message.reply_text("‚ùå Permission system not available")
        return
    
    # Ejecutar auditor√≠a
    violations = permission_manager.audit_permission_violations()
    
    message = f"üîí <b>SECURITY AUDIT REPORT</b>\n\n"
    
    if not violations:
        message += "‚úÖ <b>No security violations detected</b>\n\n"
        message += "All admin permissions are properly configured."
    else:
        message += f"‚ö†Ô∏è <b>{len(violations)} violations detected:</b>\n\n"
        
        for violation in violations[:5]:  # Mostrar solo las primeras 5
            severity_emoji = "üö®" if violation['severity'] == 'CRITICAL' else "‚ö†Ô∏è"
            message += f"{severity_emoji} {violation['violation']}\n"
        
        if len(violations) > 5:
            message += f"\n... and {len(violations) - 5} more violations"
    
    message += f"\n\nüìÖ Audit completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    
    await update.message.reply_text(message, parse_mode='HTML')

@require_permission(SystemAction.TEST_CONNECTIONS)
async def test_channel_command(update, context):
    """üîÑ MODIFICADA: Test channel con permisos"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    admin_info = permission_manager.get_admin_info(user_id)
    admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
    
    print(f"‚úÖ Test channel authorized for: {admin_name} ({user_id})")
    
    try:
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        channel_id = bot_config['channel_id']
        
        print(f"üß™ Testing direct send to channel: {channel_id}")
        
        # Test message
        test_message = f"""‚úÖ <b>MULTI-GIVEAWAY SYSTEM TEST</b>

üéØ If you see this message, the bot can send to the channel correctly.

üß™ System status: Operational
üì° Connection: Verified
üë§ Tested by: {admin_name}

üåü Available giveaways: Daily, Weekly, Monthly"""
        
        # Direct send test
        sent_message = await context.bot.send_message(
            chat_id=channel_id,
            text=test_message,
            parse_mode='HTML'
        )
        
        await update.message.reply_text(f"‚úÖ Test message sent to channel\nMessage ID: {sent_message.message_id}")
        print("‚úÖ Test message sent successfully")
        
        permission_manager.log_action(user_id, SystemAction.TEST_CONNECTIONS, f"Test channel successful - Message ID: {sent_message.message_id}")
        
    except Exception as e:
        error_msg = f"Error testing channel: {e}"
        logging.error(error_msg)
        print(f"‚ùå {error_msg}")
        await update.message.reply_text(f"‚ùå Error: {e}")
        permission_manager.log_action(user_id, SystemAction.TEST_CONNECTIONS, f"Test channel failed: {e}")

async def debug_directories():
    """üîç Verificar directorios del sistema"""
    try:
        config_loader = ConfigLoader()
        db_config = config_loader.get_database_config()
        base_path = db_config.get('base_path', './System_giveaway/data')
        
        print(f"üîç DEBUG: Configured base_path: {base_path}")
        
        for giveaway_type in ['daily', 'weekly', 'monthly']:
            data_dir = f"{base_path}/{giveaway_type}"
            participants_file = f"{data_dir}/participants.csv"
            
            print(f"üîç DEBUG: {giveaway_type} directory: {data_dir}")
            print(f"üîç DEBUG: {giveaway_type} participants file: {participants_file}")
            print(f"üîç DEBUG: Directory exists: {os.path.exists(data_dir)}")
            print(f"üîç DEBUG: File exists: {os.path.exists(participants_file)}")
            
            if os.path.exists(participants_file):
                with open(participants_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    print(f"üîç DEBUG: File size: {len(content)} characters")
                    print(f"üîç DEBUG: File content preview: {content[:200]}...")
    
    except Exception as e:
        print(f"‚ùå DEBUG: Error checking directories: {e}")


# ====================  CALLBACKS ESPECIFICOS ==============================

async def handle_user_interface_callbacks(update, context):
    """
    üéØ SPECIFIC HANDLER: Solo callbacks de interfaz de usuario
    Maneja show_rules, user interface elements, etc.
    """
    try:
        query = update.callback_query
        await query.answer()
        
        callback_data = query.data
        
        print(f"üë§ DEBUG: User interface callback: {callback_data}")
        
        # Handle different user interface callbacks
        if callback_data == "show_rules":
            # Show complete rules using existing help function
            await show_rules_inline(query)
            
        elif callback_data.startswith("user_"):
            # Handle user-specific actions (future expansion)
            await query.edit_message_text(
                "‚ÑπÔ∏è <b>User function</b>\n\nThis user interface feature is being developed.\n\nüí° Use /help for complete information.",
                parse_mode='HTML'
            )
            
        elif callback_data.startswith("start_"):
            # Handle start menu actions (future expansion)
            await query.edit_message_text(
                "üéÅ <b>Welcome!</b>\n\nUse /start to access the main participation menu.",
                parse_mode='HTML'
            )
            
        else:
            # Fallback for unknown user interface callbacks
            await query.edit_message_text(
                "‚ÑπÔ∏è <b>Interface element</b>\n\nThis interface element is not yet implemented.\n\nüí° Use /start for main menu.",
                parse_mode='HTML'
            )
            
    except Exception as e:
        logging.error(f"Error in user interface callback: {e}")
        print(f"‚ùå DEBUG: Error in user interface callback: {e}")
        await query.edit_message_text(
            "‚ùå Error processing interface element. Please try again.",
            parse_mode='HTML'
        )

# @prevent_concurrent_callback("payment_confirmation")
async def handle_payment_confirmations_only(update, context):
    """
    üéØ SPECIFIC HANDLER: Solo confirmaciones de pago
    Evita conflicto con ga_integration.py handlers
    """
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        callback_data = query.data
        
        print(f"üí∞ DEBUG: Payment confirmation callback: {callback_data} from user {user_id}")
        
        # Verify admin permissions
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        channel_id = bot_config['channel_id']
        
        member = await context.bot.get_chat_member(channel_id, user_id)
        if member.status not in ['administrator', 'creator', 'Admin 1' ]:
            await query.edit_message_text("‚ùå Only administrators can confirm payments")
            return
        
        # Process ONLY payment confirmations
        if callback_data.startswith("confirm_payment_"):
            # Parse callback: confirm_payment_<type>_<identifier>
            parts = callback_data.split("_", 3)
            if len(parts) < 4:
                await query.edit_message_text("‚ùå Invalid payment callback format")
                return
            
            giveaway_type = parts[2]  # daily, weekly, monthly
            winner_identifier = parts[3]  # username or telegram_id
            
            print(f"üí∞ DEBUG: Parsed payment - Type: {giveaway_type}, Winner: {winner_identifier}")
            
            # Validate giveaway type
            if giveaway_type not in ['daily', 'weekly', 'monthly']:
                await query.edit_message_text("‚ùå Invalid giveaway type")
                return
            
            # Get giveaway system
            giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
            if not giveaway_system:
                await query.edit_message_text(f"‚ùå {giveaway_type.title()} system not available")
                return
            
            # Find winner using helper function
            winner_telegram_id = await multi_giveaway_integration.find_winner_by_identifier(winner_identifier, giveaway_type, giveaway_system)
            
            if not winner_telegram_id:
                await query.edit_message_text(
                    f"‚ùå <b>{giveaway_type.title()} winner not found</b>\n\n"
                    f"Winner '{winner_identifier}' not found in pending {giveaway_type} winners or already processed.\n\n"
                    f"üí° The winner may have been processed already.",
                    parse_mode='HTML'
                )
                return
            
            print(f"üí∞ DEBUG: Found winner {winner_telegram_id}, confirming payment...")
            
            # üí∞ CONFIRM PAYMENT AND ANNOUNCE
            success, message = await giveaway_system.confirm_payment_and_announce(
                winner_telegram_id, user_id, giveaway_type
            )
            
            if success:
                # Get additional details for response
                prize = giveaway_system.get_prize_amount(giveaway_type)
                
                await query.edit_message_text(
                    f"‚úÖ <b>{giveaway_type.title()} Payment Confirmed Successfully</b>\n\n"
                    f"üéâ Winner: {winner_identifier}\n"
                    f"üí∞ Prize: ${prize} USD\n"
                    f"üë§ Confirmed by: {query.from_user.first_name}\n"
                    f"üìÖ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                    f"‚úÖ <b>Actions completed:</b>\n"
                    f"‚îú‚îÄ Winner announced in channel\n"
                    f"‚îú‚îÄ Private congratulation sent\n"
                    f"‚îú‚îÄ Payment record updated\n"
                    f"‚îî‚îÄ System ready for next {giveaway_type} draw\n\n"
                    f"üéØ <b>Status:</b> Payment process complete ‚úì",
                    parse_mode='HTML'
                )
                
                print(f"‚úÖ DEBUG: {giveaway_type.title()} payment confirmed successfully")
                
            else:
                await query.edit_message_text(
                    f"‚ùå <b>Error confirming {giveaway_type} payment</b>\n\n"
                    f"<b>Reason:</b> {message}\n\n"
                    f"üí° <b>This usually means:</b>\n"
                    f"‚Ä¢ Winner was already processed\n"
                    f"‚Ä¢ System error occurred\n"
                    f"‚Ä¢ Invalid winner state\n\n"
                    f"üîÑ Please check pending winners list or contact FULL_ADMIN if issue persists.",
                    parse_mode='HTML'
                )
                print(f"‚ùå DEBUG: Payment confirmation failed: {message}")
        
        else:
            # This shouldn't happen due to pattern filter, but safety check
            await query.edit_message_text("‚ùå Invalid payment callback")
            
    except Exception as e:
        logging.error(f"Error in payment confirmation handler: {e}")
        print(f"‚ùå DEBUG: Exception in payment confirmation: {e}")
        await query.edit_message_text(
            f"‚ùå <b>Payment confirmation system error</b>\n\n"
            f"An unexpected error occurred while processing the payment confirmation.\n\n"
            f"üí° <b>Please try:</b>\n"
            f"‚Ä¢ Use manual command: <code>/admin_confirm_payment &lt;winner&gt;</code>\n"
            f"‚Ä¢ Contact FULL_ADMIN if problem persists\n\n"
            f"<i>Error reference: {str(e)[:50]}...</i>",
            parse_mode='HTML'
        )

async def show_rules_inline(query):
    """Show complete rules inline when requested from button"""
    try:
        # Use existing help content but format for inline display
        try:
            config_loader = ConfigLoader()
            bot_config = config_loader.get_bot_config()
            admin_username = bot_config.get('admin_username', 'admin')
        except:
            admin_username = 'admin'
        
        rules_text = f"""üÜò <b>MULTI-GIVEAWAY RULES</b>

üåü <b>AVAILABLE GIVEAWAYS:</b>

üí∞ <b>DAILY GIVEAWAY - $250 USD</b>
‚è∞ <b>Participation:</b> Monday-Friday, 1:00 AM - 4:50 PM London Time
üéØ <b>Draw:</b> Monday-Friday at 5:00 PM London Time
üîÑ <b>Cooldown:</b> 30 days after winning

üí∞ <b>WEEKLY GIVEAWAY - $500 USD</b>
‚è∞ <b>Participation:</b> Monday 9:00 AM - Friday 5:00 PM London Time
üéØ <b>Draw:</b> Friday at 5:15 PM London Time
üîÑ <b>Cooldown:</b> 60 days after winning

üí∞ <b>MONTHLY GIVEAWAY - $1000 USD</b>
‚è∞ <b>Participation:</b> Day 1 - Last Friday of month, London Time
üéØ <b>Draw:</b> Last Friday at 5:30 PM London Time
üîÑ <b>Cooldown:</b> 90 days after winning

üìã <b>REQUIREMENTS FOR ALL GIVEAWAYS:</b>
‚úÖ Be a member of this channel
‚úÖ Active MT5 LIVE account (not demo)
‚úÖ Minimum balance of $100 USD
‚úÖ One participation per giveaway type per period

üîí <b>IMPORTANT RULES:</b>
‚Ä¢ Each MT5 account belongs to the first user who registers it
‚Ä¢ You can participate in ALL giveaway types simultaneously
‚Ä¢ Independent cooldowns for each giveaway type
‚Ä¢ Must confirm receipt of prize if you win

üìû <b>NEED HELP?</b>
Contact administrator: @{admin_username}

‚è∞ <b>CURRENT LONDON TIME:</b>
{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"""

        # Add back button
        keyboard = [[InlineKeyboardButton("üîô Back to Start", callback_data="start_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            rules_text, 
            parse_mode='HTML',
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logging.error(f"Error showing rules inline: {e}")
        await query.edit_message_text(
            "‚ùå Error loading rules. Use /help for complete information.",
            parse_mode='HTML'
        )

# =================== HELPER FUNCTIONS B√ÅSICAS ==============================

@require_permission(SystemAction.VIEW_ADVANCED_STATS)
async def debug_my_permissions(update, context):
    """üîç COMANDO TEMPORAL: Ver mis permisos actuales"""
    user_id = update.effective_user.id
    permission_manager = get_permission_manager(context)
    
    if not permission_manager:
        await update.message.reply_text("‚ùå Permission system not loaded")
        return
    
    admin_info = permission_manager.get_admin_info(user_id)
    
    if not admin_info:
        await update.message.reply_text(f"‚ùå Tu ID {user_id} no est√° en la configuraci√≥n de admins")
        return
    
    # Obtener permisos del grupo
    permission_group = admin_info.get('permission_group', 'None')
    group_permissions = permission_manager.permission_groups.get(permission_group, [])
    
    # Verificar permisos espec√≠ficos
    test_permissions = [
        SystemAction.SEND_DAILY_INVITATION,
        SystemAction.EXECUTE_DAILY_DRAW,
        SystemAction.TEST_CONNECTIONS,
        SystemAction.HEALTH_CHECK,
        SystemAction.VIEW_ADVANCED_STATS
    ]
    
    message = f"""üîç <b>DEBUG - TUS PERMISOS</b>

üë§ <b>Tu Info:</b>
‚îú‚îÄ ID: <code>{user_id}</code>
‚îú‚îÄ Nombre: {admin_info.get('name', 'N/A')}
‚îú‚îÄ Grupo: <code>{permission_group}</code>
‚îú‚îÄ Activo: {admin_info.get('active', 'N/A')}
‚îî‚îÄ Permisos en grupo: {len(group_permissions)}

üîç <b>Permisos espec√≠ficos:</b>"""

    for action in test_permissions:
        has_permission = permission_manager.has_permission(user_id, action)
        status = "‚úÖ" if has_permission else "‚ùå"
        message += f"\n{status} {action.value}"

    message += f"""

üìã <b>Todos los permisos del grupo {permission_group}:</b>
{', '.join([p.value for p in group_permissions[:10]])}{'...' if len(group_permissions) > 10 else ''}

üîß <b>Total permisos en tu grupo:</b> {len(group_permissions)}
üîß <b>Total acciones disponibles:</b> {len(SystemAction)}"""

    await update.message.reply_text(message, parse_mode='HTML')

# üÜï ADD: Installation check function
def check_automation_dependencies():
    """Check if required dependencies for automation are installed"""
    try:
        import apscheduler
        print("‚úÖ APScheduler available")
        return True
    except ImportError:
        print("‚ùå APScheduler not found")
        print("üí° Install with: pip install apscheduler")
        return False

# ==================== NOTIFICACI√ìN A ADMINS AUTORIZADOS ====================

async def notify_payment_confirmed_to_authorized_admins(context, winner_identifier, giveaway_type, confirmed_by, prize):
    """
    üîî NOTIFICAR confirmaci√≥n de pago solo a admins con permisos relevantes
    """
    permission_manager = get_permission_manager(context)
    
    # Determinar qui√©n debe recibir la notificaci√≥n
    relevant_permissions = [
        SystemAction.VIEW_PAYMENT_HISTORY,
        SystemAction.VIEW_ALL_PENDING_WINNERS,
        SystemAction.MANAGE_ADMINS  # FULL_ADMIN siempre debe saber
    ]
    
    # Tambi√©n incluir admins que pueden confirmar este tipo espec√≠fico
    type_permission_map = {
        'daily': SystemAction.CONFIRM_DAILY_PAYMENTS,
        'weekly': SystemAction.CONFIRM_WEEKLY_PAYMENTS,
        'monthly': SystemAction.CONFIRM_MONTHLY_PAYMENTS
    }
    
    if giveaway_type in type_permission_map:
        relevant_permissions.append(type_permission_map[giveaway_type])
    
    # Obtener todos los admins autorizados (sin duplicados)
    authorized_admins = set()
    for permission in relevant_permissions:
        admins_with_permission = permission_manager.get_admins_with_permission(permission)
        authorized_admins.update(admins_with_permission)
    
    if not authorized_admins:
        logging.warning(f"No authorized admins found for {giveaway_type} payment confirmation notification")
        return
    
    # Mensaje de notificaci√≥n
    notification_message = f"""‚úÖ <b>{giveaway_type.upper()} PAYMENT CONFIRMED</b>

üèÜ <b>Winner:</b> {winner_identifier}
üí∞ <b>Prize:</b> ${prize} USD
üë§ <b>Confirmed by:</b> {confirmed_by}
üìÖ <b>Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

‚úÖ <b>Actions completed:</b>
‚îú‚îÄ Winner announced in channel
‚îú‚îÄ Private congratulation sent
‚îî‚îÄ System updated for next {giveaway_type} draw

üí° <b>Status:</b> Payment process complete ‚úì"""
    
    # Enviar a cada admin autorizado
    success_count = 0
    for admin_id in authorized_admins:
        try:
            await context.bot.send_message(
                chat_id=admin_id,
                text=notification_message,
                parse_mode='HTML'
            )
            success_count += 1
        except Exception as e:
            logging.error(f"Error notifying admin {admin_id} about {giveaway_type} payment confirmation: {e}")
    
    logging.info(f"{giveaway_type.title()} payment confirmation sent to {success_count}/{len(authorized_admins)} authorized admins")

async def show_view_only_dashboard_simple(update, context, admin_info):
    """üìä Dashboard simple para VIEW_ONLY - VERSI√ìN SIMPLIFICADA"""
    try:
        user_id = update.effective_user.id
        admin_name = admin_info.get('name', 'VIEW_ONLY User')
        
        print(f"üîç DEBUG: Showing VIEW_ONLY dashboard for {admin_name} ({user_id})")
        
        # Obtener estad√≠sticas b√°sicas
        total_today = 0
        active_windows = 0
        giveaway_status = []
        
        for giveaway_type in ['daily', 'weekly', 'monthly']:
            giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
            if giveaway_system:
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                today_count = stats.get('today_participants', 0)
                is_open = giveaway_system.is_participation_window_open(giveaway_type)
                
                total_today += today_count
                if is_open:
                    active_windows += 1
                
                status_emoji = "üü¢" if is_open else "üî¥"
                giveaway_status.append(f"{status_emoji} <b>{giveaway_type.upper()}</b> (${prize}): {today_count} today")
        
        current_time = datetime.now()
        
        message = f"""üìä <b>VIEW_ONLY MONITORING DASHBOARD</b>

üë§ <b>Admin:</b> {admin_name}
üîí <b>Access Level:</b> VIEW_ONLY
üìÖ <b>Date:</b> {current_time.strftime('%Y-%m-%d %H:%M')} London Time

üìä <b>Today's Activity:</b>
‚îú‚îÄ Total participants: <b>{total_today}</b>
‚îú‚îÄ Active windows: <b>{active_windows}/3</b>
‚îî‚îÄ System status: <b>‚úÖ Operational</b>

üéØ <b>Giveaway Overview:</b>
{chr(10).join(giveaway_status)}

üí° <b>Your VIEW_ONLY Permissions:</b>
‚úÖ Monitor daily participation statistics
‚úÖ Check system operational status
‚úÖ View participation window status
‚ùå Execute giveaways (requires PAYMENT_SPECIALIST+)
‚ùå View pending winners (requires PAYMENT_SPECIALIST+)
‚ùå System administration (requires FULL_ADMIN)

üîÑ Use buttons below for more information."""

        # Botones simples y funcionales
        buttons = [
            [
                InlineKeyboardButton("üìà Today's Details", callback_data="view_only_today_details"),
                InlineKeyboardButton("üè• System Check", callback_data="view_only_health")
            ],
            [
                InlineKeyboardButton("üîÑ Refresh Data", callback_data="view_only_refresh"),
                InlineKeyboardButton("‚ÑπÔ∏è Permissions", callback_data="view_only_permissions_info")
            ]
        ]
        
        reply_markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
        
        print(f"‚úÖ DEBUG: VIEW_ONLY dashboard sent successfully to {admin_name}")
        
    except Exception as e:
        logging.error(f"Error showing VIEW_ONLY dashboard: {e}")
        print(f"‚ùå DEBUG: Error in VIEW_ONLY dashboard: {e}")
        await update.message.reply_text("‚ùå Error loading VIEW_ONLY dashboard")


# ==================== üîÑ MAIN FUNCTION MODIFICADA ====================

# Global variable for multi-giveaway integration
multi_giveaway_integration = None

async def main():
    """üîÑ MODIFICADA: Main function con integraci√≥n del sistema de permisos"""
    
    global multi_giveaway_integration

    await debug_directories()
    
    # Configure logging
    logging.basicConfig(
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        level=logging.INFO,
        handlers=[
            logging.FileHandler('multi_giveaway_bot.log'),
            logging.StreamHandler()
        ]
    )
    
    logging.info("Starting Multi-Type Giveaway Bot with Permission System...")
    
    # Verify configuration
    if not verify_multi_giveaway_configuration():
        print("‚ùå Configuration incomplete. Please check config.json")
        return
    
    # Load configuration
    try:
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        
        BOT_TOKEN = bot_config['token']
        CHANNEL_ID = bot_config['channel_id']
        ADMIN_ID = bot_config['admin_id']
        ADMIN_USERNAME = bot_config.get('admin_username', 'admin')
        
    except Exception as e:
        print(f"‚ùå Configuration error: {e}")
        return
    
    # Create Telegram application
    app = Application.builder().token(BOT_TOKEN).build()

    # üÜï INICIALIZAR SAFETY MANAGER AQU√ç (despu√©s de crear app, antes de permisos)
    setup_async_safety(app)
    print("üîí Async Safety Manager initialized")

    permission_manager = setup_permission_system(app, "admin_permissions.json")
    print("‚úÖ Permission system initialized successfully")

    # Create MT5 API
    mt5_api = RealMT5API()

    
    
    # ===== üÜï NUEVOS HANDLERS CON PERMISOS GRANULARES =====
    
    # SYSTEM COMMANDS (sin permisos - p√∫blico)
    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(CommandHandler("help", help_command))
    
    # COMANDOS ADMIN ESPEC√çFICOS POR TIPO
    app.add_handler(CommandHandler("admin_send_daily", admin_send_daily_invitation))
    app.add_handler(CommandHandler("admin_send_weekly", admin_send_weekly_invitation))
    app.add_handler(CommandHandler("admin_send_monthly", admin_send_monthly_invitation))
    
    app.add_handler(CommandHandler("admin_run_daily", admin_run_daily_draw))
    app.add_handler(CommandHandler("admin_run_weekly", admin_run_weekly_draw))
    app.add_handler(CommandHandler("admin_run_monthly", admin_run_monthly_draw))

    # COMANDOS EXISTENTES CON PERMISOS
    app.add_handler(CommandHandler("stats", stats_command))
    app.add_handler(CommandHandler("test_channel", test_channel_command))
    app.add_handler(CommandHandler("health_check", health_check_command))
    app.add_handler(CommandHandler("debug_permissions", debug_my_permissions))

    # COMANDOS CR√çTICOS FALTANTES
    
    app.add_handler(CommandHandler("admin_security_audit", admin_security_audit))

    print("‚úÖ test_botTTT.py commands registered FIRST")

    app.add_handler(CallbackQueryHandler(
        lambda update, context: handle_payment_confirmations_only(update, context),
        pattern="^confirm_payment_(daily|weekly|monthly)_[^_]+$"  # ‚Üê M√°s espec√≠fico
    ))
    print("‚úÖ test_botTTT.py specific callbacks registered")
    
    # üéØ ONLY user interface (m√°s espec√≠fico)
    app.add_handler(CallbackQueryHandler(
        handle_user_interface_callbacks,
        # pattern="^(show_rules|start_main|user_)$"  # Solo estos espec√≠ficos
        pattern="^(show_rules|start_main|user_)$"
    ))

    # app.add_handler(CallbackQueryHandler(
    #     handle_payment_confirmations_only,
    #     # pattern="^confirm_payment_[^_]+_[^_]+$"  # M√°s espec√≠fico
    #     pattern="^confirm_payment_[^_]+_[^_]+$"
    # ))
    
    
    # INITIALIZE MULTI-GIVEAWAY INTEGRATION WITH AUTOMATION
    multi_giveaway_integration = MultiGiveawayIntegration(
        application=app,
        mt5_api=mt5_api,
        config_file="config.json"
    )
    # üÜï ADD: Setup automatic draws
    multi_giveaway_integration.setup_automatic_draws()


    # 5Ô∏è‚É£ TODO: Callbacks y otros comandos se agregar√°n en pr√≥ximas fases
    
    # ===== üîß CALLBACK HANDLERS - FIXED APPROACH =====
    
    
    
    
    mt5_handler = MessageHandler(
        filters.TEXT & filters.ChatType.PRIVATE & ~filters.COMMAND & filters.Regex(r'^\d+$'),
        multi_giveaway_integration._handle_mt5_input_universal

    )
    app.add_handler(mt5_handler)

    print("‚úÖ All handlers configured in correct order")
    
    # Get automation status for startup info
    automation_status = multi_giveaway_integration.get_automation_status()
    enabled_types = [t for t, enabled in automation_status.items() 
                    if enabled and t not in ['scheduler_running', 'scheduler_available']]

    print("‚úÖ MultiGiveawayIntegration initialized (handlers registered AFTER)")

    print("ü§ñ Automatic Draw System Initialized")
    print(f"   ‚îú‚îÄ Scheduler: {'üü¢ RUNNING' if automation_status['scheduler_available'] else '‚ùå FAILED'}")
    print(f"   ‚îú‚îÄ Auto-enabled types: {', '.join(enabled_types) if enabled_types else 'None (manual mode)'}")
    print(f"   ‚îú‚îÄ Manual override: ‚úÖ Always available")
    print(f"   ‚îî‚îÄ Control panel: /admin_panel ‚Üí Automation")
    
    logging.info("All command handlers configured successfully")
    
    
    
    logging.info("All command handlers configured WITHOUT conflicts")
    
    # ===== REST OF MAIN FUNCTION UNCHANGED =====
    
    print("üöÄ Multi-Type Giveaway Bot with Automatization Started Successfully")
    print(f"üì¢ Channel: {CHANNEL_ID}")
    print(f"üë§ Admin: {ADMIN_ID} (@{ADMIN_USERNAME})")
    print(f"ü§ñ Bot token: {BOT_TOKEN[:10]}...")
    print(f"üîê Permission system: ACTIVE")
    print(f"ü§ñ Automation system: {'ACTIVE' if automation_status['scheduler_available'] else 'FAILED (check dependencies)'}")
    
    print("\nüéØ Available Giveaways:")
    for giveaway_type in ['daily', 'weekly', 'monthly']:
        giveaway_system = multi_giveaway_integration.get_giveaway_system(giveaway_type)
        prize = giveaway_system.get_prize_amount(giveaway_type)
        cooldown = giveaway_system.get_cooldown_days(giveaway_type)
        is_open = giveaway_system.is_participation_window_open(giveaway_type)
        status = "üü¢ OPEN" if is_open else "üî¥ CLOSED"
        print(f"   üí∞ {giveaway_type.title()}: ${prize} (cooldown: {cooldown}d) - {status}")
    
    print("\nüìã System Architecture:")
    print("   üéØ Payment confirmations: test_botTTT.py")
    print("   üéØ User interface: test_botTTT.py") 
    print("   üéØ Admin panels & analytics: ga_integration.py")
    print("   üéØ Automatic draws: ga_integration.py")
    print("   üéØ Manual draws: test_botTTT.py")
    
    print(f"\nüïê Automation Schedule (London Time):")
    print(f"   üìÖ Daily: Monday-Friday at 17:00 ({'üü¢ ENABLED' if automation_status.get('daily') else 'üî¥ DISABLED'})")
    print(f"   üìÖ Weekly: Friday at 17:15 ({'üü¢ ENABLED' if automation_status.get('weekly') else 'üî¥ DISABLED'})")
    print(f"   üìÖ Monthly: Last Friday at 17:30 ({'üü¢ ENABLED' if automation_status.get('monthly') else 'üî¥ DISABLED'})")
    recurring_status = multi_giveaway_integration.recurring_invitations_enabled
    
    print(f"\nüîî Recurring Invitations Schedule:")
    print(f"   üìß Auto-invitations: {'üü¢ ENABLED' if recurring_status else 'üî¥ DISABLED'}")
    if recurring_status:
        print(f"   ‚îú‚îÄ Daily invitations: every {multi_giveaway_integration.invitation_frequencies['daily']}h")
        print(f"   ‚îú‚îÄ Weekly invitations: every {multi_giveaway_integration.invitation_frequencies['weekly']}h")
        print(f"   ‚îî‚îÄ Monthly invitations: every {multi_giveaway_integration.invitation_frequencies['monthly']}h")


    print(f"\nüì± Admin Controls:")
    print(f"   üéõÔ∏è Main panel: /admin_panel")
    print(f"   ü§ñ Automation: /admin_panel ‚Üí Automation button")
    print(f"   üë§ Manual draws: /admin_run_daily, /admin_run_weekly, /admin_run_monthly")
    print(f"   üí≥ Payment confirmation: /admin_confirm_daily, /admin_confirm_weekly, /admin_confirm_monthly")
    
    # Start bot (rest unchanged)
    try:
        await app.initialize()
        await app.start()
        
        await app.updater.start_polling(
            allowed_updates=["message", "callback_query"],
            drop_pending_updates=True
        )
        
        stop_event = asyncio.Event()
        
        def signal_handler(signum, frame):
            print("\nüõë Stopping multi-type bot...")
            stop_event.set()
        
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
        
        await stop_event.wait()
        
    except KeyboardInterrupt:
        print("\nüõë Bot stopped by user")
    except Exception as e:
        logging.error(f"Error in bot: {e}")
    finally:
        try:
            print("üßπ Cleaning up resources...")
            # üÜï ADD: Shutdown automation scheduler
            if multi_giveaway_integration and multi_giveaway_integration.scheduler:
                multi_giveaway_integration.shutdown_scheduler()
                print("‚úÖ Automation scheduler shutdown")
            
            if app.updater.running:
                await app.updater.stop()
            await app.stop()
            await app.shutdown()
            logging.info("Bot finished correctly")
        except Exception as cleanup_error:
            logging.error(f"Error in cleanup: {cleanup_error}")

# ==================== ENTRY POINT ====================

if __name__ == "__main__":
    print("üéØ Multi-Type Giveaway Bot with Automatic Draws - PHASE 2")
    print("=" * 70)
    
    # Check dependencies
    print("üîç Checking dependencies...")
    automation_available = check_automation_dependencies()

    # Verify required files
    required_files = ['ga_manager.py', 'ga_integration.py', 'config_loader.py', 'admin_permissions.py']
    missing_files = [f for f in required_files if not os.path.exists(f)]
    
    if missing_files:
        print(f"‚ùå Missing files: {missing_files}")
        print("Make sure you have all giveaway system files")
        exit(1)
    
    print("‚úÖ System files verified")
    
    # Check admin permissions config
    if not os.path.exists("admin_permissions.json"):
        print("‚ö†Ô∏è admin_permissions.json not found!")
        print("üí° Creating basic configuration...")
        from admin_permissions import create_your_specific_config
        create_your_specific_config()
        print("‚úÖ Basic configuration created.")
        print("üîß IMPORTANT: Edit admin_permissions.json and replace ID placeholders with real Telegram IDs")
        exit(0)
    
    print("‚úÖ Permission configuration found")
    
    # Setup files if needed
    if not os.path.exists("config.json"):
        print("‚ö†Ô∏è Setting up multi-giveaway files...")
        setup_multi_giveaway_files()
        print("‚úÖ Files created. Please configure config.json and run again.")
        exit(0)
    
    print("\nüîß CURRENT CONFIGURATION:")
    try:
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        giveaway_configs = config_loader.get_giveaway_configs()
        automation_config = config_loader.get_all_config().get('automation', {})
        
        print(f"   ü§ñ Bot Token: {bot_config['token'][:10]}...")
        print(f"   üì¢ Channel ID: {bot_config['channel_id']}")
        print(f"   üë§ Admin ID: {bot_config['admin_id']}")
        print(f"   üéØ Giveaway Types: {', '.join(giveaway_configs.keys())}")
        print(f"   ü§ñ Automation: {'‚úÖ Enabled' if automation_config.get('enabled', False) else '‚ö†Ô∏è Disabled'}")
        
        # Show prizes
        for giveaway_type, config in giveaway_configs.items():
            auto_enabled = automation_config.get('default_auto_modes', {}).get(giveaway_type, False)
            auto_status = "ü§ñ AUTO" if auto_enabled else "üë§ MANUAL"
            print(f"   üí∞ {giveaway_type.title()}: ${config['prize']} - {auto_status}")
            
    except Exception as e:
        print(f"   ‚ùå Configuration error: {e}")
        exit(1)
    
    print("\nüîê PERMISSION SYSTEM: ACTIVE")
    print("üåç TIMEZONE: Europe/London")
    print("‚è∞ TIME RESTRICTIONS: Enabled for specified admins")
    print("üìä GRANULAR PERMISSIONS: By giveaway type")
    print(f"ü§ñ AUTOMATION: {'Available' if automation_available else 'Requires APScheduler'}")
    
    print("\nüìù AUTOMATION FEATURES:")
    print("‚úÖ Dynamic on/off control per giveaway type")
    print("‚úÖ Admin channel notifications")
    print("‚úÖ Automatic winner selection and notification")
    print("‚úÖ Manual override always available")
    print("‚úÖ Duplicate draw protection")
    print("‚úÖ Error handling and notifications")
    print("‚úÖ Zero conflicts with manual operations")
    
    print("\nüì± TESTING COMMANDS:")
    print("- /admin_panel (then click 'Automation' button)")
    print("- /admin_run_daily (manual override)")
    print("- /admin_confirm_daily @username (payment confirmation)")
    print("- /health_check (system status)")
    
    if not automation_available:
        print("\n‚ö†Ô∏è  IMPORTANT: Install APScheduler for automatic draws:")
        print("   pip install apscheduler")
        print("   The system will work in manual-only mode without it.")
    print("=" * 70)
    
    # Run bot
    asyncio.run(main())