# from tele_algo.SSSGGGAAA.utils import automation_manager
from utils.admin_permission import SystemAction
import logging
from telegram.ext import CallbackQueryHandler, MessageHandler, CommandHandler, filters
from telegram import InlineKeyboardButton, InlineKeyboardMarkup
import asyncio
import datetime
from utils.config_loader import ConfigLoader




# Handlers principales de callbacks:
async def _handle_admin_panel_callbacks(integration_instance, automation_manager, context, update):
        """üîÑ ENHANCED: Complete callback handler with ALL missing callbacks"""
        try:
            query = update.callback_query
            await query.answer()
            
            user_id = query.from_user.id
            callback_data = query.data

            # Verify admin permissions
            member = await context.bot.get_chat_member(integration_instance.channel_id, user_id)
            if member.status not in ['administrator', 'creator']:
                await query.edit_message_text("‚ùå Only administrators can use this function")
                return
            
            # VIEW_ONLY detection
            permission_manager = integration_instance._get_permission_manager_from_callback()
            if permission_manager:
                admin_info = permission_manager.get_admin_info(user_id)
                if admin_info and admin_info.get('permission_group') == 'VIEW_ONLY':
                    # await self._show_view_only_panel(query)
                    await _handle_view_only_callbacks(integration_instance, query, callback_data)
                    return
            
            print(f"üîç DEBUG: Processing callback: {callback_data}")

            # üÜï ADD: Automation callbacks
            if callback_data.startswith("automation_"):
                await _handle_automation_callbacks(integration_instance, automation_manager, update, context)
                # pri:nt(f"üîÑ DEBUG: Automation callback {callback_data} - should be handled by automation handler")
                return
            
            # ===== üÜï PANEL PRINCIPAL CALLBACKS (LOS QUE FALTABAN) =====
            if callback_data == "panel_pending_winners":
                await _show_all_pending_inline(integration_instance, query)
            elif callback_data == "panel_statistics":
                await _show_combined_stats_inline(integration_instance,query)
            elif callback_data == "panel_send_invitations":
                await _send_all_invitations_inline(integration_instance, query)
            elif callback_data == "panel_execute_draws":
                await _execute_all_draws_inline(integration_instance, query)
            elif callback_data == "panel_health":
                await _execute_system_health_check(integration_instance, query)
            elif callback_data == "panel_maintenance":
                await _show_maintenance_panel_inline(integration_instance, query)
            elif callback_data == "panel_advanced_analytics":
                await _show_unified_multi_analytics_inline(integration_instance, query)
            elif callback_data == "panel_basic_analytics":
                await _show_combined_stats_inline(integration_instance, query)
            elif callback_data == "panel_daily":
                await _show_type_panel_inline(integration_instance,query, 'daily')
            elif callback_data == "panel_weekly":
                await _show_type_panel_inline(integration_instance,query, 'weekly')
            elif callback_data == "panel_monthly":
                await _show_type_panel_inline(integration_instance,query, 'monthly')
            
            # ===== TYPE-SPECIFIC PANEL ACTIONS (EXISTENTES) =====
            else:
                # Procesar callbacks por tipo usando loop (c√≥digo existente)
                handled = False
                for giveaway_type in integration_instance.available_types:
                    if callback_data == f"panel_type_{giveaway_type}":
                        await _show_type_panel_inline(integration_instance,query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_send_invitation_{giveaway_type}":
                        await _execute_send_invitation_inline(integration_instance,query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_run_giveaway_{giveaway_type}":
                        await _execute_run_giveaway_inline(integration_instance, query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_pending_winners_{giveaway_type}":
                        await _show_pending_winners_inline(integration_instance, query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_full_stats_{giveaway_type}":
                        await _show_full_stats_inline(integration_instance,query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_refresh_{giveaway_type}":
                        await _refresh_type_panel(integration_instance, query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_analytics_{giveaway_type}":
                        await _show_analytics_inline(integration_instance, query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"panel_top_users_{giveaway_type}":
                        await _show_top_users_inline(integration_instance, query, giveaway_type)
                        handled = True
                        break
                    elif callback_data == f"analytics_{giveaway_type}_30":
                        await _show_analytics_detailed_inline(integration_instance,query, giveaway_type, 30)
                        handled = True
                        break
                    elif callback_data == f"analytics_{giveaway_type}_7":
                        await _show_analytics_detailed_inline(integration_instance, query, giveaway_type, 7)
                        handled = True
                        break
                    elif callback_data == f"analytics_{giveaway_type}_90":
                        await _show_analytics_detailed_inline(integration_instance, query, giveaway_type, 90)
                        handled = True
                        break
                    elif callback_data == f"account_report_{giveaway_type}":
                        await _show_account_report_for_type_inline(query, giveaway_type)
                        handled = True
                        break
                
                
                if handled:
                    return
                
                # ===== UNIFIED PANEL ACTIONS (EXISTENTES) =====
                if callback_data == "panel_unified_main":
                    await _show_unified_panel_inline(integration_instance, query)
                # if callback_data == "panel_unified_main":
                #     await self._show_main_admin_panel_inline(query)
                elif callback_data == "panel_unified_refresh":
                    await _refresh_unified_panel(integration_instance, query)
                elif callback_data == "unified_all_pending":
                    await _show_all_pending_inline(integration_instance, query)
                elif callback_data == "unified_combined_stats":
                    await _show_combined_stats_inline(integration_instance, query)
                elif callback_data == "unified_send_all_invitations":
                    await _send_all_invitations_inline(integration_instance, query)
                elif callback_data == "unified_execute_all_draws":
                    await _execute_all_draws_inline(integration_instance, query)
                elif callback_data == "unified_multi_analytics":
                    await _show_unified_multi_analytics_inline(integration_instance, query)
                elif callback_data == "unified_cross_analytics":
                    await _show_cross_analytics_inline(integration_instance, query)
                elif callback_data == "unified_maintenance":
                    await _show_maintenance_panel_inline(integration_instance, query)
                elif callback_data == "analytics_cross_type":
                    await _show_cross_type_analytics_inline(integration_instance, query)
                elif callback_data == "analytics_combined":
                    await _show_combined_analytics_inline(integration_instance, query)
                elif callback_data == "analytics_revenue":
                    await _show_giveaway_cost_analysis(integration_instance, query)
                elif callback_data == "analytics_user_overlap":
                    await _show_user_overlap_analysis(integration_instance, query)
                elif callback_data == "maintenance_cleanup":
                    await _execute_maintenance_cleanup(integration_instance, query)
                elif callback_data == "maintenance_backup":
                    await _execute_maintenance_backup(integration_instance, query)
                elif callback_data == "maintenance_health":
                    await _execute_system_health_check(integration_instance, query)
                elif callback_data == "maintenance_files":
                    await _show_file_status(integration_instance, query)
                elif callback_data == "type_selector_main":
                    await _show_type_selector_inline(integration_instance, query)
                elif callback_data == "panel_refresh":
                    await _refresh_unified_panel(integration_instance, query)
                elif callback_data == "no_action":
                    await query.answer("‚ÑπÔ∏è No action available", show_alert=False)
                elif callback_data == "view_only_health":
                    await _show_view_only_health(integration_instance, query)
                elif callback_data == "view_only_today_details":
                    await _show_view_only_today_details(integration_instance, query)
                elif callback_data == "view_only_refresh":
                    await _show_view_only_panel(integration_instance, query)
                elif callback_data == "view_only_permissions_info":
                    await _show_view_only_permissions_info(integration_instance, query)
                elif callback_data in [
                    "analytics_revenue_impact", "analytics_user_behavior", "analytics_time_trends", 
                    "analytics_deep_dive", "analytics_revenue_detailed", "analytics_user_patterns", 
                    "analytics_time_patterns", "analytics_export_report", "analytics_efficiency_trends",
                    "analytics_user_engagement", "analytics_loyalty_patterns", "analytics_user_behavior_patterns",
                    "analytics_time_analysis", "analytics_deep_analysis"
                ]:
                    await _handle_placeholder_analytics(query, callback_data)
                else:
                    print(f"‚ùå DEBUG: Truly unrecognized callback: {callback_data}")
                    await query.edit_message_text(f"‚ùå Unrecognized action: {callback_data}")
                    
        except Exception as e:
            logging.error(f"Error in panel callback: {e}")
            print(f"üö® DEBUG ERROR in callback: {e}")
            await query.edit_message_text("‚ùå Error processing action")


async def _handle_automation_callbacks(integration_instance,automation_manager, update, context):
        """üÜï Handle automation control callbacks"""

        query = update.callback_query
    
        # 2Ô∏è‚É£ SEGUNDO: INMEDIATAMENTE responder al callback (OBLIGATORIO)
        await query.answer()  # ‚Üê AQU√ç VA, L√çNEA 3 DE LA FUNCI√ìN

        # query = update.callback_query 
        callback_data = query.data
        user_id = query.from_user.id

        
        # Verify permissions
        permission_manager = integration_instance._get_permission_manager_from_callback()
        if not permission_manager or not permission_manager.has_permission(user_id, SystemAction.MANAGE_ADMINS):
            print(f"‚ùå DEBUG: Permission denied for user {user_id}")
            await query.edit_message_text(
                "‚ùå <b>Access Denied</b>\n\nAutomation control requires MANAGE_ADMINS permission.",
                parse_mode='HTML'
            )
            return
        print(f"‚úÖ DEBUG: Permission granted for user {user_id}")
        
        try:
            if callback_data == "automation_control":
                await _show_automation_control_panel(integration_instance,automation_manager, query, context)
                
            elif callback_data.startswith("automation_toggle_"):

                giveaway_type = callback_data.replace("automation_toggle_", "")

                # üêõ BUGFIX: Manejar caso especial de invitations
                if giveaway_type == "invitations":
                    print(f"üîî DEBUG: Processing invitation toggle")
                    # Handle recurring invitations toggle
                    success = automation_manager.toggle_recurring_invitations()
                    
                    if success:
                        status_text = "ENABLED" if automation_manager.recurring_invitations_enabled else "DISABLED"
                        response_message = f"""‚úÖ <b>Recurring Invitations {status_text}</b>

    üîî <b>Status:</b> {'üü¢ ENABLED' if automation_manager.recurring_invitations_enabled else 'üî¥ DISABLED'}

    ‚è∞ <b>Frequencies:</b>
    ‚îú‚îÄ Daily: every {automation_manager.invitation_frequencies['daily']} hours
    ‚îú‚îÄ Weekly: every {automation_manager.invitation_frequencies['weekly']} hours
    ‚îî‚îÄ Monthly: every {automation_manager.invitation_frequencies['monthly']} hours

    üí° <b>What this means:</b>
    - Automatic invitations will {'start sending' if automation_manager.recurring_invitations_enabled else 'stop sending'}
    - Manual invitations are always available
    - Settings can be changed anytime

    üéõÔ∏è Use "‚è∞ Set Frequencies" to adjust timing."""
                        
                        buttons = [[InlineKeyboardButton("üè† Back to Automation", callback_data="automation_control")]]
                        reply_markup = InlineKeyboardMarkup(buttons)
                        
                        await query.edit_message_text(
                            response_message, 
                            parse_mode='HTML',
                            reply_markup=reply_markup
                        )
                    else:
                        await query.edit_message_text(
                            f"‚ùå <b>Error toggling invitations</b>\n\n"
                            f"Could not change recurring invitation settings.\n\n"
                            f"üí° Current status: {'üü¢ ENABLED' if automation_manager.recurring_invitations_enabled else 'üî¥ DISABLED'}",
                            parse_mode='HTML'
                        )
                    return
                
                # Handle giveaway type toggles (daily, weekly, monthly)
                if giveaway_type in ['daily', 'weekly', 'monthly']:
                    current_status = automation_manager.get_automation_status()
                    new_status = not current_status[giveaway_type]
                    
                    success = automation_manager.toggle_automatic_mode(giveaway_type, new_status)
                    
                    if success:
                        status_text = "ENABLED" if new_status else "DISABLED"
                        await query.edit_message_text(
                            f"‚úÖ <b>{giveaway_type.title()} automation {status_text}</b>\n\n"
                            f"ü§ñ Automatic draws: {'üü¢ ON' if new_status else 'üî¥ OFF'}\n"
                            f"üìÖ Next scheduled: {automation_manager._get_next_execution_time(giveaway_type) if new_status else 'Manual only'}",
                            parse_mode='HTML'
                        )
                    else:
                        await query.edit_message_text("‚ùå Error toggling automation")
                    return
                    
            elif callback_data == "automation_enable_all":
                results = {}
                for giveaway_type in ['daily', 'weekly', 'monthly']:
                    results[giveaway_type] = automation_manager.toggle_automatic_mode(giveaway_type, True)
                
                successful = sum(1 for success in results.values() if success)
                
                await query.edit_message_text(
                    f"‚úÖ <b>Bulk Automation Enable</b>\n\n"
                    f"üü¢ Successfully enabled: {successful}/3 types\n"
                    f"ü§ñ All automatic draws are now ACTIVE\n\n"
                    f"Daily: Monday-Friday at 5:00 PM\n"
                    f"Weekly: Friday at 5:15 PM\n"
                    f"Monthly: Last Friday at 5:30 PM\n\n"
                    f"London Time Zone",
                    parse_mode='HTML'
                )
                
            elif callback_data == "automation_disable_all":
                results = {}
                for giveaway_type in ['daily', 'weekly', 'monthly']:
                    results[giveaway_type] = automation_manager.toggle_automatic_mode(giveaway_type, False)
                
                successful = sum(1 for success in results.values() if success)
                
                await query.edit_message_text(
                    f"‚è∏Ô∏è <b>Bulk Automation Disable</b>\n\n"
                    f"üî¥ Successfully disabled: {successful}/3 types\n"
                    f"ü§ñ All automatic draws are now INACTIVE\n\n"
                    f"üìå Manual draws remain available:\n"
                    f"‚Ä¢ /admin_run_daily\n"
                    f"‚Ä¢ /admin_run_weekly\n"
                    f"‚Ä¢ /admin_run_monthly",
                    parse_mode='HTML'
                )

            

            elif callback_data == "automation_set_frequencies":
                await _show_frequency_settings(automation_manager,query)
                
            elif callback_data == "automation_refresh":
                await _show_automation_control_panel(integration_instance,automation_manager, query, context)
                
            elif callback_data == "automation_back_to_panel":
                await _show_unified_panel_inline(integration_instance, query)
                
        except Exception as e:
            logging.error(f"Error in automation callback: {e}")
            await query.edit_message_text("‚ùå Error processing automation command")

async def _handle_view_only_callbacks(integration_instance, query, callback_data: str):
        """üÜï Enrutador espec√≠fico para usuarios VIEW_ONLY"""
        # user_id = query.from_user.id
    
        # üü¢ CALLBACKS PERMITIDOS PARA VIEW_ONLY (expandida)
        allowed_view_only_callbacks = [
            "view_only_health", "view_only_today_details", "view_only_refresh", 
            "view_only_permissions_info", "panel_refresh", "panel_unified_refresh",
            "panel_unified_main", "no_action"
        ]
        
        if callback_data in allowed_view_only_callbacks:
            # Ejecutar callbacks permitidos
            if callback_data == "view_only_health":
                await _show_view_only_health(integration_instance, query)
            elif callback_data == "view_only_today_details":
                await _show_view_only_today_details(integration_instance, query)
            elif callback_data == "view_only_permissions_info":
                await _show_view_only_permissions_info(integration_instance, query)
            elif callback_data in ["view_only_refresh", "panel_refresh", "panel_unified_refresh", "panel_unified_main"]:
                await _show_view_only_panel(integration_instance, query)
            elif callback_data == "no_action":
                await query.answer("‚ÑπÔ∏è No action available", show_alert=False)
            return
        
        # üî¥ ACCIONES ESPEC√çFICAMENTE BLOQUEADAS PARA VIEW_ONLY
        blocked_actions = [
            "unified_send_all_invitations", "unified_execute_all_draws",
            "unified_all_pending", "unified_maintenance", 
            "unified_multi_analytics", "analytics_", "maintenance_",
            "panel_send_invitation_", "panel_run_giveaway_", "panel_pending_winners_"
        ]
        
        is_blocked = any(callback_data.startswith(blocked) for blocked in blocked_actions)
        
        if is_blocked:
            await query.edit_message_text(
                f"‚ùå <b>Access Denied - VIEW_ONLY</b>\n\n"
                f"This function requires PAYMENT_SPECIALIST or higher permissions.\n\n"
                f"üí° Returning to your VIEW_ONLY panel...",
                parse_mode='HTML'
            )
            await asyncio.sleep(1)
            await _show_view_only_panel(integration_instance, query)
            return
        return


async def _handle_confirm_payment_callback(integration_instance, update, context, giveaway_type):
        """üîÑ MODIFIED: Handle payment confirmation with type awareness"""
        try:
            query = update.callback_query
            await query.answer()
            
            user_id = query.from_user.id
            
            # Verify admin permissions
            member = await context.bot.get_chat_member(integration_instance.channel_id, user_id)
            if member.status not in ['administrator', 'creator']:
                await query.edit_message_text("‚ùå Only administrators can confirm payments")
                return
            
            # Extract winner identifier from callback_data
            callback_data = query.data
            if not callback_data.startswith(f"confirm_payment_{giveaway_type}_"):
                await query.edit_message_text("‚ùå Invalid callback")
                return
            
            winner_identifier = callback_data.replace(f"confirm_payment_{giveaway_type}_", "")
            
            # Find winner by username or telegram_id
            winner_telegram_id = await _find_winner_by_identifier(integration_instance, winner_identifier, giveaway_type)
            
            if not winner_telegram_id:
                await query.edit_message_text(
                    f"‚ùå <b>{giveaway_type.title()} winner not found</b>\n\nNo pending {giveaway_type} winner found with: <code>{winner_identifier}</code>",
                    parse_mode='HTML'
                )
                return
            
            # Confirm payment and proceed with announcements
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            success, message = await giveaway_system.confirm_payment_and_announce(
                winner_telegram_id, user_id, giveaway_type
            )
            
            if success:
                await query.edit_message_text(
                    f"‚úÖ <b>{giveaway_type.title()} payment confirmed successfully</b>\n\nThe winner has been announced publicly and notified privately.",
                    parse_mode='HTML'
                )
            else:
                await query.edit_message_text(f"‚ùå {message}", parse_mode='HTML')
            
        except Exception as e:
            logging.error(f"Error in {giveaway_type} payment confirmation callback: {e}")
            await query.edit_message_text("‚ùå Error processing confirmation")


# Funciones inline de paneles:

async def _show_type_panel_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Show type-specific panel inline"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            stats = giveaway_system.get_stats(giveaway_type)
            pending_count = len(giveaway_system.get_pending_winners(giveaway_type))
            prize = giveaway_system.get_prize_amount(giveaway_type)

            is_open = giveaway_system.is_participation_window_open(giveaway_type)
            window_status = "üü¢ Open" if is_open else "üî¥ Closed"

            # Get last winner info if exists
            recent_winners = giveaway_system.get_pending_winners(giveaway_type)
            last_winner_info = ""
            if recent_winners:
                winner = recent_winners[0]
                username = winner.get('username', '').strip()
                first_name = winner.get('first_name', 'N/A')
                winner_display = f"@{username}" if username else first_name
                last_winner_info = f"\nüèÜ <b>Last winner:</b> {winner_display}"
            
            message = f"""üéõÔ∏è <b>{giveaway_type.upper()} CONTROL PANEL</b>

üí∞ <b>Prize:</b> ${prize} USD
‚è∞ <b>Participation Window:</b> {window_status}

üìä <b>Today's participants:</b> {stats.get('today_participants', 0)}
‚è≥ <b>Pending winners:</b> {pending_count}
üèÜ <b>Total winners:</b> {stats.get('total_winners', 0)}

üöÄ <b>Actions available:</b>"""
            
            buttons = [
                [
                    InlineKeyboardButton("üì¢ Send invitation", callback_data=f"panel_send_invitation_{giveaway_type}"),
                    InlineKeyboardButton("üé≤ Execute draw", callback_data=f"panel_run_giveaway_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton(f"üëë Pending ({pending_count})", callback_data=f"panel_pending_winners_{giveaway_type}"),
                    InlineKeyboardButton("üìä Statistics", callback_data=f"panel_full_stats_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton("üìà Analytics", callback_data=f"panel_analytics_{giveaway_type}"),
                    InlineKeyboardButton("üë• Top users", callback_data=f"panel_top_users_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton("üîÑ Other types", callback_data="type_selector_main"),
                    InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing {giveaway_type} panel inline: {e}")
            await query.edit_message_text("‚ùå Error loading panel")

async def _show_type_selector_inline(integration_instance, query):
        """üÜï NEW: Show type selector inline"""
        try:
            message = "üéØ <b>SELECT GIVEAWAY TYPE</b>\n\nChoose which giveaway panel to access:"
            
            buttons = []
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                prize = giveaway_system.get_prize_amount()
                participants = giveaway_system._get_period_participants_count()
                pending = len(giveaway_system.get_pending_winners(giveaway_type))
                
                button_text = f"üìÖ {giveaway_type.title()} (${prize}) - {participants} today, {pending} pending"
                callback_data = f"panel_type_{giveaway_type}"
                buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
            
            buttons.append([InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")])
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing type selector: {e}")
            await query.edit_message_text("‚ùå Error loading type selector")

async def _show_unified_panel_inline(integration_instance, query):
        """üîÑ REFACTORED: Mostrar panel principal usando funci√≥n base compartida"""
        try:
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            
            if not permission_manager:
                await query.edit_message_text("‚ùå Permission system not initialized")
                return
            
            # üÜï USAR FUNCI√ìN BASE COMPARTIDA
            message, reply_markup, status = await integration_instance._generate_main_admin_panel_content(user_id, permission_manager)
            
            if status == 'VIEW_ONLY':
                # üö® DETECCI√ìN VIEW_ONLY - usar funci√≥n espec√≠fica para callbacks
                await _show_view_only_panel(integration_instance,query)
                return
            elif status == 'ERROR':
                await query.edit_message_text("‚ùå Error loading admin panel")
                return
            
            # ‚úÖ MOSTRAR PANEL PRINCIPAL (SUCCESS case)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing unified panel inline: {e}")
            await query.edit_message_text("‚ùå Error loading admin panel")

async def _refresh_unified_panel(integration_instance, query):
        """üÜï NEW: Refresh unified panel"""
        try:
            await _show_unified_panel_inline(integration_instance, query)
            # üÜï ADD: Success confirmation via popup
            await query.answer("‚úÖ Panel refreshed", show_alert=False)
        except Exception as e:
            logging.error(f"Error refreshing unified panel: {e}")
            await query.answer("‚ùå Refresh failed", show_alert=True)

async def _show_all_pending_inline(integration_instance, query):
        """üÜï NEW: Show all pending winners from all types inline"""
        try:
            all_pending = {}
            total_pending = 0
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                pending = giveaway_system.get_pending_winners(giveaway_type)
                if pending:
                    all_pending[giveaway_type] = pending
                    total_pending += len(pending)
            
            if total_pending == 0:
                buttons = [[InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")]]
                reply_markup = InlineKeyboardMarkup(buttons)
                await query.edit_message_text("‚ÑπÔ∏è No pending winners in any type", reply_markup=reply_markup)
                return
            
            message = f"üìã <b>ALL PENDING WINNERS ({total_pending})</b>\n\n"
            buttons = []
            
            for giveaway_type, pending_winners in all_pending.items():
                message += f"üéØ <b>{giveaway_type.upper()}:</b>\n"
                
                for i, winner in enumerate(pending_winners, 1):
                    username = winner.get('username', '').strip()
                    first_name = winner.get('first_name', 'N/A')
                    
                    if username:
                        command_identifier = username
                        display_name = f"{first_name} (@{username})"
                    else:
                        command_identifier = winner['telegram_id']
                        display_name = f"{first_name} (ID: {winner['telegram_id']})"
                    
                    message += f"{i}. {display_name} - ${winner['prize']}\n"
                    
                    # Button for each winner
                    button_text = f"‚úÖ {giveaway_type.title()} - {first_name}"
                    callback_data = f"confirm_payment_{giveaway_type}_{command_identifier}"
                    buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
                
                message += "\n"
            
            buttons.append([InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")])
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing all pending inline: {e}")
            await query.edit_message_text("‚ùå Error getting all pending winners")

async def _show_combined_stats_inline(integration_instance, query):
        """üÜï NEW: Show combined statistics inline"""
        try:
            combined_totals = {
                'total_participants': 0,
                'total_winners': 0,
                'total_distributed': 0,
                'total_pending': 0
            }
            
            type_details = {}
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                pending_count = len(giveaway_system.get_pending_winners(giveaway_type))
                
                type_details[giveaway_type] = {
                    'today': stats.get('today_participants', 0),
                    'total': stats.get('total_participants', 0),
                    'winners': stats.get('total_winners', 0),
                    'distributed': stats.get('total_prize_distributed', 0),
                    'pending': pending_count,
                    'prize': giveaway_system.get_prize_amount()
                }
                
                combined_totals['total_participants'] += stats.get('total_participants', 0)
                combined_totals['total_winners'] += stats.get('total_winners', 0)
                combined_totals['total_distributed'] += stats.get('total_prize_distributed', 0)
                combined_totals['total_pending'] += pending_count
            
            message = f"""üìä <b>COMBINED STATISTICS</b>

üåü <b>GLOBAL TOTALS:</b>
‚îú‚îÄ Total participants: <b>{combined_totals['total_participants']}</b>
‚îú‚îÄ Total winners: <b>{combined_totals['total_winners']}</b>
‚îú‚îÄ Money distributed: <b>${combined_totals['total_distributed']}</b>
‚îî‚îÄ Pending winners: <b>{combined_totals['total_pending']}</b>

üìã <b>BREAKDOWN BY TYPE:</b>"""

            for giveaway_type, details in type_details.items():
                message += f"""

üéØ <b>{giveaway_type.upper()} (${details['prize']}):</b>
‚îú‚îÄ Today: {details['today']} participants
‚îú‚îÄ Total: {details['total']} participants
‚îú‚îÄ Winners: {details['winners']}
‚îú‚îÄ Distributed: ${details['distributed']}
‚îî‚îÄ Pending: {details['pending']}"""

            buttons = [
                [InlineKeyboardButton("üìà Cross-type analytics", callback_data="unified_cross_analytics")],
                [InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)

            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing combined stats: {e}")
            await query.edit_message_text("‚ùå Error getting combined statistics")

async def _send_all_invitations_inline(integration_instance, query):
        """üÜï NEW: Send invitations for all types inline"""
        try:
            results = {}
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                success = await giveaway_system.send_invitation()
                results[giveaway_type] = success
            
            message = "üì¢ <b>BULK INVITATION RESULTS</b>\n\n"
            
            successful = []
            failed = []
            
            for giveaway_type, success in results.items():
                if success:
                    successful.append(giveaway_type)
                    message += f"‚úÖ {giveaway_type.title()}: Sent successfully\n"
                else:
                    failed.append(giveaway_type)
                    message += f"‚ùå {giveaway_type.title()}: Failed to send\n"
            
            message += f"\nüìä <b>Summary:</b> {len(successful)} successful, {len(failed)} failed"
            
            buttons = [[InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")]]
            reply_markup = InlineKeyboardMarkup(buttons)
            
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error sending all invitations: {e}")
            await query.edit_message_text("‚ùå Error sending invitations")


async def _execute_all_draws_inline(integration_instance, query):
        """üÜï NEW: Execute draws for all types inline"""
        try:
            results = {}
            
            for giveaway_type in integration_instance.available_types:
                try:
                    giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                    await giveaway_system.run_giveaway(giveaway_type)
                    
                    pending_winners = giveaway_system.get_pending_winners(giveaway_type)
                    results[giveaway_type] = {
                        'success': True,
                        'winners': len(pending_winners),
                        'winner_name': pending_winners[0].get('first_name', 'Unknown') if pending_winners else None
                    }
                except Exception as e:
                    results[giveaway_type] = {
                        'success': False,
                        'error': str(e)
                    }
            
            message = "üé≤ <b>BULK DRAW EXECUTION RESULTS</b>\n\n"
            
            total_winners = 0
            
            for giveaway_type, result in results.items():
                if result['success']:
                    winners = result['winners']
                    total_winners += winners
                    if winners > 0:
                        message += f"‚úÖ {giveaway_type.title()}: {result['winner_name']} selected\n"
                    else:
                        message += f"‚úÖ {giveaway_type.title()}: No eligible participants\n"
                else:
                    message += f"‚ùå {giveaway_type.title()}: Error - {result['error']}\n"
            
            message += f"\nüìä <b>Total new winners:</b> {total_winners}"
            
            if total_winners > 0:
                message += f"\n\nüí° Check pending winners for payment confirmation"
            
            buttons = [
                [InlineKeyboardButton("üëë View all pending", callback_data="unified_all_pending")],
                [InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error executing all draws: {e}")
            await query.edit_message_text("‚ùå Error executing draws")



# Funciones inline de ejecuci√≥n:

async def _execute_send_invitation_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Execute send invitation inline"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            success = await giveaway_system.send_invitation()
            
            if success:
                message = f"‚úÖ <b>{giveaway_type.title()} invitation sent</b>\n\nInvitation has been sent to the channel successfully."
            else:
                message = f"‚ùå <b>Error sending {giveaway_type} invitation</b>\n\nCould not send invitation to channel."
            
            buttons = [
                [InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")],
                [InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error executing {giveaway_type} invitation: {e}")
            await query.edit_message_text("‚ùå Error sending invitation")

async def _execute_run_giveaway_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Execute giveaway draw inline"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            await giveaway_system.run_giveaway(giveaway_type)
            
            # Check results
            pending_winners = giveaway_system.get_pending_winners(giveaway_type)
            pending_count = len(pending_winners)
            
            if pending_count > 0:
                winner = pending_winners[0]
                username = winner.get('username', '').strip()
                first_name = winner.get('first_name', 'N/A')
                winner_display = f"@{username}" if username else first_name
                prize = giveaway_system.get_prize_amount(giveaway_type)
                
                message = f"""‚úÖ <b>{giveaway_type.title()} draw executed</b>

üéØ <b>Winner selected:</b> {winner_display}
üìä <b>MT5 Account:</b> {winner['mt5_account']}
üí∞ <b>Prize:</b> ${prize} USD
‚è≥ <b>Status:</b> Pending payment confirmation

üí° Check your private messages for complete details."""
            else:
                message = f"‚úÖ <b>{giveaway_type.title()} draw executed</b>\n\nNo eligible participants found today."
            
            buttons = [
                [InlineKeyboardButton(f"üëë View pending", callback_data=f"panel_pending_winners_{giveaway_type}")],
                [InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")],
                [InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)
            
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error executing {giveaway_type} draw: {e}")
            await query.edit_message_text("‚ùå Error executing draw")

async def _show_pending_winners_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Show pending winners for specific type inline"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            pending_winners = giveaway_system.get_pending_winners(giveaway_type)
            
            if not pending_winners:
                buttons = [
                    [InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")],
                    [InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")]
                ]
                reply_markup = InlineKeyboardMarkup(buttons)
                await query.edit_message_text(
                    f"‚ÑπÔ∏è No pending {giveaway_type} winners",
                    reply_markup=reply_markup
                )
                return
            
            # Format list
            pending_list = ""
            buttons = []
            
            for i, winner in enumerate(pending_winners, 1):
                username = winner.get('username', '').strip()
                first_name = winner.get('first_name', 'N/A')
                
                if username:
                    command_identifier = username
                    display_name = f"<b>{first_name}</b> (@{username})"
                else:
                    command_identifier = winner['telegram_id']
                    display_name = f"<b>{first_name}</b> (ID: {winner['telegram_id']})"
                
                pending_list += f"{i}. {display_name}\n"
                pending_list += f"   üìä MT5: <code>{winner['mt5_account']}</code>\n"
                pending_list += f"   üí∞ Prize: ${winner['prize']} USD\n"
                pending_list += f"   üìÖ Selected: {winner['selected_time']}\n\n"
                
                # Confirmation button
                button_text = f"‚úÖ Confirm payment to {first_name}"
                callback_data = f"confirm_payment_{giveaway_type}_{command_identifier}"
                buttons.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
            
            # Navigation buttons
            buttons.extend([
                [InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")],
                [InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")]
            ])
            
            message = f"""üìã <b>{giveaway_type.upper()} PENDING WINNERS</b>

{pending_list}üí° <b>Instructions:</b>
1Ô∏è‚É£ Transfer to MT5 account
2Ô∏è‚É£ Press confirmation button
3Ô∏è‚É£ Bot will announce winner automatically

‚ö° <b>Quick buttons:</b>"""
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing {giveaway_type} pending winners inline: {e}")
            await query.edit_message_text("‚ùå Error getting pending winners")

async def _show_full_stats_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Show full statistics for specific type inline"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            stats = giveaway_system.get_stats(giveaway_type)
            pending_count = len(giveaway_system.get_pending_winners(giveaway_type))
            prize = giveaway_system.get_prize_amount(giveaway_type)
            
            message = f"""üìä <b>{giveaway_type.upper()} STATISTICS</b>

üí∞ <b>Prize Amount:</b> ${prize} USD

üë• <b>Today's participants:</b> {stats.get('today_participants', 0)}
üìà <b>Total participants:</b> {stats.get('total_participants', 0)}
üèÜ <b>Total winners:</b> {stats.get('total_winners', 0)}
üí∞ <b>Money distributed:</b> ${stats.get('total_prize_distributed', 0)}
‚è≥ <b>Pending winners:</b> {pending_count}

‚è∞ Next draw: Check schedule

<i>Updated: {stats.get('timestamp', 'N/A')}</i>"""

            buttons = [
                [InlineKeyboardButton(f"üìà Advanced analytics", callback_data=f"analytics_{giveaway_type}_30")],
                [InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")],
                [InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")]
            ]
            reply_markup = InlineKeyboardMarkup(buttons)

            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing {giveaway_type} stats inline: {e}")
            await query.edit_message_text("‚ùå Error getting statistics")

async def _refresh_type_panel(integration_instance, query, giveaway_type):
        """üÜï NEW: Refresh type-specific panel"""
        try:
            await _show_type_panel_inline(integration_instance, query, giveaway_type)
        except Exception as e:
            logging.error(f"Error refreshing {giveaway_type} panel: {e}")
            await query.edit_message_text("‚ùå Error refreshing panel")


# Analytics inline:

async def _show_analytics_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Show analytics for specific type"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            stats = giveaway_system.get_stats(giveaway_type)
            prize = giveaway_system.get_prize_amount(giveaway_type)

            total_participants = stats.get('total_participants', 0)
            total_winners = stats.get('total_winners', 0)
            total_distributed = stats.get('total_prize_distributed', 0)
            today_participants = stats.get('today_participants', 0)
            cost_per_participant = total_distributed / max(total_participants, 1)

            win_rate = (total_winners / max(total_participants, 1)) * 100
            avg_prize_per_day = total_distributed / max(30, 1)  # Approximate monthly average
            
            
            message = f"""üìà <b>{giveaway_type.upper()} ANALYTICS</b>

        üí∞ <b>Configuration:</b>
        ‚îú‚îÄ Prize Amount: ${prize} USD
        ‚îî‚îÄ Reset Frequency: {giveaway_type}

        üìä <b>Participation Analytics:</b>
        ‚îú‚îÄ Today's participants: <b>{today_participants}</b>
        ‚îú‚îÄ Total participants: <b>{total_participants:,}</b>
        ‚îú‚îÄ Daily efficiency: {'üü¢ High' if today_participants > 10 else 'üü° Medium' if today_participants > 5 else 'üî¥ Low'} ({today_participants}/day)
        ‚îî‚îÄ Participation trend: {'üìà Growing' if today_participants > 5 else 'üìä Stable'}

        üèÜ <b>Winner Analytics:</b>
        ‚îú‚îÄ Total winners: <b>{total_winners}</b>
        ‚îú‚îÄ Win rate: <b>{win_rate:.2f}%</b>
        ‚îú‚îÄ Money distributed: <b>${total_distributed:,}</b>
        ‚îî‚îÄ Cost per participant: <b>${cost_per_participant:.2f}</b>

        üìà <b>Performance Metrics:</b>
        ‚îú‚îÄ Average prize/month: <b>${avg_prize_per_day * 30:.2f}</b>
        ‚îú‚îÄ Success rate: {'üü¢ Excellent' if win_rate > 10 else 'üü° Good' if win_rate > 5 else 'üü† Moderate' if win_rate > 2 else 'üî¥ Low'}
        ‚îú‚îÄ Engagement level: {'üü¢ High' if total_participants > 100 else 'üü° Medium' if total_participants > 50 else 'üî¥ Growing'}
        ‚îî‚îÄ System efficiency: <b>{(total_winners / max(total_participants, 1) * 1000):.1f}</b> winners per 1000 participants

            üîç <b>Select detailed period:</b>"""

            buttons = [
                [
                    InlineKeyboardButton("üìä Last 7 days", callback_data=f"analytics_{giveaway_type}_7"),
                    InlineKeyboardButton("üìä Last 30 days", callback_data=f"analytics_{giveaway_type}_30")
                ],
                [
                    InlineKeyboardButton("üìä Last 90 days", callback_data=f"analytics_{giveaway_type}_90"),
                    InlineKeyboardButton("üë• Top users", callback_data=f"panel_top_users_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton("üè¶ Account report", callback_data=f"account_report_{giveaway_type}"),
                    InlineKeyboardButton("üí∞ Revenue analysis", callback_data=f"revenue_analysis_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}"),
                    InlineKeyboardButton("üè† Unified panel", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing analytics for {giveaway_type}: {e}")
            await query.edit_message_text("‚ùå Error loading analytics")

async def _show_analytics_detailed_inline(integration_instance, query, giveaway_type, days):
        """üÜï NEW: Show detailed analytics for specific period"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            stats = giveaway_system.get_stats(giveaway_type)
            prize = giveaway_system.get_prize_amount(giveaway_type)
            
            # Calculate detailed metrics for the period
            total_participants = stats.get('total_participants', 0)
            total_winners = stats.get('total_winners', 0)
            total_distributed = stats.get('total_prize_distributed', 0)
            
            avg_participants_per_day = total_participants / days if days > 0 else 0
            win_rate = (total_winners / max(total_participants, 1)) * 100
            cost_per_participant = total_distributed / max(total_participants, 1)
            
            message = f"""üìä <b>{giveaway_type.upper()} DETAILED ANALYTICS ({days} days)</b>

    üí∞ <b>Prize:</b> ${prize} USD per draw

    üìà <b>Period Analysis:</b>
    ‚îú‚îÄ Total participants: {total_participants}
    ‚îú‚îÄ Daily average: {avg_participants_per_day:.1f}
    ‚îú‚îÄ Total winners: {total_winners}
    ‚îú‚îÄ Money distributed: ${total_distributed}
    ‚îú‚îÄ Win rate: {win_rate:.2f}%
    ‚îî‚îÄ Cost per participant: ${cost_per_participant:.2f}

    üìä <b>Performance:</b>
    ‚îú‚îÄ Active days in period: {min(days, 30)}
    ‚îú‚îÄ Average engagement: {'High' if avg_participants_per_day > 10 else 'Medium' if avg_participants_per_day > 5 else 'Low'}
    ‚îú‚îÄ Distribution efficiency: {(total_distributed / (days * prize)):.1f}x expected
    ‚îî‚îÄ Growth trend: {'Positive' if total_participants > days * 5 else 'Stable'}

    üìã <b>Recommendations:</b>
    ‚Ä¢ {'Increase promotion' if avg_participants_per_day < 10 else 'Maintain current strategy'}
    ‚Ä¢ {'Consider prize adjustment' if win_rate < 5 else 'Prize level optimal'}

    <i>Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</i>"""

            buttons = [
                [
                    InlineKeyboardButton("üë• Top users", callback_data=f"panel_top_users_{giveaway_type}"),
                    InlineKeyboardButton("üè¶ Account report", callback_data=f"account_report_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton("üìà Other periods", callback_data=f"panel_analytics_{giveaway_type}"),
                    InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing detailed analytics: {e}")
            await query.edit_message_text("‚ùå Error loading detailed analytics")

async def _show_top_users_inline(integration_instance, query, giveaway_type):
        """üÜï NEW: Show top users for specific type"""
        try:
            giveaway_system = integration_instance.giveaway_systems[giveaway_type]
            # This would need to be implemented in ga_manager.py
            # For now, showing placeholder
            stats = giveaway_system.get_stats(giveaway_type)
            prize = giveaway_system.get_prize_amount(giveaway_type)
            
            message = f"""üë• <b>TOP {giveaway_type.upper()} USERS</b>

    üí∞ <b>Giveaway:</b> ${prize} USD

    üèÜ <b>Most Active Participants:</b>

    üìä <b>Current Period Analysis:</b>
    ‚îú‚îÄ Today's participants: {stats.get('today_participants', 0)}
    ‚îú‚îÄ Total unique users: {stats.get('total_participants', 0)}
    ‚îú‚îÄ Total winners: {stats.get('total_winners', 0)}
    ‚îî‚îÄ Analysis period: All time

    üí° <b>Top Users Analysis:</b>
    This feature shows the most active participants in {giveaway_type} giveaways.

    üîß <b>Advanced Analysis Available:</b>
    ‚Ä¢ Participation frequency
    ‚Ä¢ Win rates per user
    ‚Ä¢ Account usage patterns
    ‚Ä¢ Loyalty metrics

    üí° This feature requires advanced analytics implementation."""

            buttons = [
                [
                    InlineKeyboardButton("üìà Analytics", callback_data=f"panel_analytics_{giveaway_type}"),
                    InlineKeyboardButton("üè¶ Account report", callback_data=f"account_report_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing top users: {e}")
            await query.edit_message_text("‚ùå Error loading top users")

async def _show_unified_multi_analytics_inline(integration_instance, query):
        """üÜï NEW: Show unified multi-analytics"""
        try:
            combined_stats = {}
            total_participants_all = 0
            total_winners_all = 0
            total_distributed_all = 0
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                
                combined_stats[giveaway_type] = {
                    'participants': stats.get('total_participants', 0),
                    'winners': stats.get('total_winners', 0),
                    'distributed': stats.get('total_prize_distributed', 0),
                    'prize': giveaway_system.get_prize_amount(giveaway_type)
                }
                
                total_participants_all += stats.get('total_participants', 0)
                total_winners_all += stats.get('total_winners', 0)
                total_distributed_all += stats.get('total_prize_distributed', 0)
            
            message = f"""üìà <b>UNIFIED MULTI-ANALYTICS</b>

    üåü <b>GLOBAL PERFORMANCE:</b>
    ‚îú‚îÄ Total participants: {total_participants_all}
    ‚îú‚îÄ Total winners: {total_winners_all}
    ‚îú‚îÄ Total distributed: ${total_distributed_all}
    ‚îú‚îÄ Overall win rate: {(total_winners_all / max(total_participants_all, 1) * 100):.2f}%
    ‚îî‚îÄ Average per winner: ${total_distributed_all / max(total_winners_all, 1):.2f}

    üìä <b>BY GIVEAWAY TYPE:</b>"""

            for giveaway_type, stats in combined_stats.items():
                efficiency = (stats['winners'] / max(stats['participants'], 1)) * 100
                message += f"""
    üéØ <b>{giveaway_type.upper()} (${stats['prize']}):</b>
    ‚îú‚îÄ Participants: {stats['participants']}
    ‚îú‚îÄ Winners: {stats['winners']}
    ‚îú‚îÄ Distributed: ${stats['distributed']}
    ‚îî‚îÄ Efficiency: {efficiency:.1f}%"""

            message += f"\n\nüí° <b>Cross-type insights:</b>\n‚Ä¢ Most popular: {max(combined_stats.keys(), key=lambda k: combined_stats[k]['participants'])}\n‚Ä¢ Highest efficiency: {max(combined_stats.keys(), key=lambda k: combined_stats[k]['winners'] / max(combined_stats[k]['participants'], 1))}"

            buttons = [
                [
                    InlineKeyboardButton("üìä Cross-type comparison", callback_data="unified_cross_analytics"),
                    InlineKeyboardButton("üìà Revenue analysis", callback_data="analytics_revenue")
                ],
                [
                    InlineKeyboardButton("üè† Back to unified", callback_data="panel_refresh")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing unified analytics: {e}")
            await query.edit_message_text("‚ùå Error loading unified analytics")


async def _show_cross_type_analytics_inline(integration_instance, query):
        """üÜï NEW: Show cross-type analytics comparison (different from cross_analytics)"""
        try:
            # Get data for all types
            type_comparison = {}
            total_global_participants = 0
            total_global_winners = 0
            total_global_distributed = 0
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                pending = len(giveaway_system.get_pending_winners(giveaway_type))
                
                participants = stats.get('total_participants', 0)
                winners = stats.get('total_winners', 0)
                distributed = stats.get('total_prize_distributed', 0)
                
                type_comparison[giveaway_type] = {
                    'prize': prize,
                    'participants': participants,
                    'winners': winners,
                    'distributed': distributed,
                    'pending': pending,
                    'win_rate': (winners / max(participants, 1)) * 100,
                    'avg_cost_per_participant': distributed / max(participants, 1),
                    'efficiency_score': (winners * prize) / max(distributed, 1) if distributed > 0 else 0
                }
                
                total_global_participants += participants
                total_global_winners += winners
                total_global_distributed += distributed
            
            # Calculate rankings
            most_participants = max(type_comparison.keys(), key=lambda k: type_comparison[k]['participants'])
            highest_win_rate = max(type_comparison.keys(), key=lambda k: type_comparison[k]['win_rate'])
            most_efficient = max(type_comparison.keys(), key=lambda k: type_comparison[k]['efficiency_score'])
            
            message = f"""üîÑ <b>CROSS-TYPE ANALYTICS COMPARISON</b>

    üèÜ <b>RANKINGS:</b>
    ‚îú‚îÄ üë• Most Popular: <b>{most_participants.title()}</b>
    ‚îú‚îÄ üéØ Highest Win Rate: <b>{highest_win_rate.title()}</b>
    ‚îî‚îÄ ‚ö° Most Efficient: <b>{most_efficient.title()}</b>

    üåç <b>GLOBAL TOTALS:</b>
    ‚îú‚îÄ Combined Participants: <b>{total_global_participants}</b>
    ‚îú‚îÄ Combined Winners: <b>{total_global_winners}</b>
    ‚îú‚îÄ Total Distributed: <b>${total_global_distributed}</b>
    ‚îî‚îÄ Overall Win Rate: <b>{(total_global_winners / max(total_global_participants, 1) * 100):.2f}%</b>

    üìä <b>DETAILED BREAKDOWN:</b>"""

            for giveaway_type, data in type_comparison.items():
                message += f"""

    üéØ <b>{giveaway_type.upper()} (${data['prize']}):</b>
    ‚îú‚îÄ Participants: {data['participants']} ({(data['participants']/max(total_global_participants,1)*100):.1f}% of total)
    ‚îú‚îÄ Winners: {data['winners']} ‚îÇ Win Rate: {data['win_rate']:.2f}%
    ‚îú‚îÄ Distributed: ${data['distributed']} ‚îÇ Pending: {data['pending']}
    ‚îú‚îÄ Cost/Participant: ${data['avg_cost_per_participant']:.2f}
    ‚îî‚îÄ Efficiency Score: {data['efficiency_score']:.2f}"""

            message += f"\n\nüí° <b>Strategic Recommendations:</b>"
            
            # Generate recommendations based on data
            lowest_participation = min(type_comparison.keys(), key=lambda k: type_comparison[k]['participants'])
            if type_comparison[lowest_participation]['participants'] < total_global_participants * 0.2:
                message += f"\n‚Ä¢ Consider increasing promotion for {lowest_participation} giveaway"
            
            if total_global_winners > 0:
                message += f"\n‚Ä¢ System efficiency: {(total_global_distributed / (total_global_winners * 100)):.1f}x baseline"
            
            message += f"\n‚Ä¢ Peak performance type: {most_efficient.title()}"

            buttons = [
                [
                    InlineKeyboardButton("üìà Revenue Impact", callback_data="analytics_revenue_impact"),
                    InlineKeyboardButton("üë• User Behavior", callback_data="analytics_user_behavior")
                ],
                [
                    InlineKeyboardButton("üìä Time Analysis", callback_data="analytics_time_trends"),
                    InlineKeyboardButton("üîç Deep Dive", callback_data="analytics_deep_dive")
                ],
                [
                    InlineKeyboardButton("üè† Back to Analytics", callback_data="unified_multi_analytics"),
                    InlineKeyboardButton("üè† Unified Panel", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing cross-type analytics: {e}")
            await query.edit_message_text("‚ùå Error loading cross-type analytics")

async def _show_combined_analytics_inline(integration_instance, query):
        """üÜï NEW: Show combined analytics from all giveaway types"""
        try:
            # Collect all data
            combined_data = {
                'total_participants_all_time': 0,
                'total_winners_all_time': 0,
                'total_money_distributed': 0,
                'total_pending_all_types': 0,
                'active_giveaway_types': 0,
                'by_type_details': {},
                'performance_metrics': {},
                'time_analysis': {}
            }
            
            current_month = datetime.now().strftime('%Y-%m')
            current_week = datetime.now().strftime('%Y-W%U')
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                pending = giveaway_system.get_pending_winners(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                cooldown = giveaway_system.get_cooldown_days(giveaway_type)
                
                # Basic stats
                participants = stats.get('total_participants', 0)
                winners = stats.get('total_winners', 0)
                distributed = stats.get('total_prize_distributed', 0)
                today_participants = stats.get('today_participants', 0)
                
                combined_data['total_participants_all_time'] += participants
                combined_data['total_winners_all_time'] += winners
                combined_data['total_money_distributed'] += distributed
                combined_data['total_pending_all_types'] += len(pending)
                
                if participants > 0:
                    combined_data['active_giveaway_types'] += 1
                
                # Detailed breakdown
                combined_data['by_type_details'][giveaway_type] = {
                    'prize': prize,
                    'cooldown': cooldown,
                    'participants': participants,
                    'winners': winners,
                    'distributed': distributed,
                    'pending': len(pending),
                    'today_participants': today_participants,
                    'win_rate': (winners / max(participants, 1)) * 100,
                    'activity_level': 'High' if today_participants > 10 else 'Medium' if today_participants > 5 else 'Low',
                    'roi_efficiency': (distributed / max(participants * prize, 1)) * 100 if participants > 0 else 0
                }
            
            # Calculate performance metrics
            overall_win_rate = (combined_data['total_winners_all_time'] / max(combined_data['total_participants_all_time'], 1)) * 100
            avg_prize_per_winner = combined_data['total_money_distributed'] / max(combined_data['total_winners_all_time'], 1)
            system_efficiency = (combined_data['total_winners_all_time'] / max(combined_data['total_participants_all_time'], 1)) * 100
            
            message = f"""üìä <b>COMBINED ANALYTICS DASHBOARD</b>

    üåü <b>GLOBAL PERFORMANCE OVERVIEW:</b>
    ‚îú‚îÄ üë• Total Participants: <b>{combined_data['total_participants_all_time']:,}</b>
    ‚îú‚îÄ üèÜ Total Winners: <b>{combined_data['total_winners_all_time']:,}</b>
    ‚îú‚îÄ üí∞ Money Distributed: <b>${combined_data['total_money_distributed']:,}</b>
    ‚îú‚îÄ ‚è≥ Pending Payments: <b>{combined_data['total_pending_all_types']}</b>
    ‚îî‚îÄ üéØ Active Types: <b>{combined_data['active_giveaway_types']}/{len(integration_instance.available_types)}</b>

    üìà <b>KEY METRICS:</b>
    ‚îú‚îÄ Overall Win Rate: <b>{overall_win_rate:.2f}%</b>
    ‚îú‚îÄ Average Prize/Winner: <b>${avg_prize_per_winner:.2f}</b>
    ‚îú‚îÄ System Efficiency: <b>{system_efficiency:.1f}%</b>
    ‚îî‚îÄ Daily Activity: <b>{sum(data['today_participants'] for data in combined_data['by_type_details'].values())} participants today</b>

    üéØ <b>PERFORMANCE BY TYPE:</b>"""

            # Show each type's performance
            for giveaway_type, data in combined_data['by_type_details'].items():
                activity_emoji = "üü¢" if data['activity_level'] == 'High' else "üü°" if data['activity_level'] == 'Medium' else "üî¥"
                
                message += f"""

    {activity_emoji} <b>{giveaway_type.upper()} (${data['prize']}, {data['cooldown']}d cooldown):</b>
    ‚îú‚îÄ Participants: {data['participants']:,} ‚îÇ Winners: {data['winners']}
    ‚îú‚îÄ Distributed: ${data['distributed']:,} ‚îÇ Pending: {data['pending']}
    ‚îú‚îÄ Today: {data['today_participants']} ‚îÇ Win Rate: {data['win_rate']:.2f}%
    ‚îî‚îÄ ROI Efficiency: {data['roi_efficiency']:.1f}% ‚îÇ Activity: {data['activity_level']}"""

            # Add insights
            best_performing = max(combined_data['by_type_details'].keys(), 
                                key=lambda k: combined_data['by_type_details'][k]['win_rate'])
            most_active = max(combined_data['by_type_details'].keys(), 
                            key=lambda k: combined_data['by_type_details'][k]['today_participants'])
            
            message += f"""

    üí° <b>INSIGHTS & TRENDS:</b>
    ‚îú‚îÄ ü•á Best Win Rate: <b>{best_performing.title()}</b> ({combined_data['by_type_details'][best_performing]['win_rate']:.2f}%)
    ‚îú‚îÄ üî• Most Active Today: <b>{most_active.title()}</b> ({combined_data['by_type_details'][most_active]['today_participants']} participants)
    ‚îú‚îÄ üí∏ Total Investment: <b>${sum(data['participants'] * data['prize'] for data in combined_data['by_type_details'].values()):,}</b>
    ‚îî‚îÄ üìä Success Rate: <b>{(combined_data['total_winners_all_time'] / max(len(integration_instance.available_types) * 365, 1) * 100):.1f}% daily average</b>

    <i>üïí Report generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</i>"""

            buttons = [
                [
                    InlineKeyboardButton("üìà Cross-Type Comparison", callback_data="analytics_cross_type"),
                    InlineKeyboardButton("üí∞ Revenue Analysis", callback_data="analytics_revenue_detailed")
                ],
                [
                    InlineKeyboardButton("üìä User Analytics", callback_data="analytics_user_patterns"),
                    InlineKeyboardButton("‚è∞ Time Patterns", callback_data="analytics_time_patterns")
                ],
                [
                    InlineKeyboardButton("üìã Export Report", callback_data="analytics_export_report"),
                    InlineKeyboardButton("üè† Unified Panel", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing combined analytics: {e}")
            await query.edit_message_text("‚ùå Error loading combined analytics")

async def _show_cross_analytics_inline(integration_instance, query):
        """üîÑ MODIFIED: Enhanced cross-type analytics with dynamic insights"""
        try:
            comparison_data = {}
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                
                participants = stats.get('total_participants', 0)
                winners = stats.get('total_winners', 0)
                today_participants = stats.get('today_participants', 0)
                
                comparison_data[giveaway_type] = {
                    'prize': prize,
                    'participants': participants,
                    'winners': winners,
                    'today_participants': today_participants,
                    'roi': (winners / max(participants, 1)) * 100,
                    'cost_efficiency': prize / max(participants, 1) if participants > 0 else float('inf'),
                    'engagement_today': today_participants,
                    'win_rate': (winners / max(participants, 1)) * 100
                }
            
            # Find performance leaders
            most_popular = max(comparison_data.keys(), key=lambda k: comparison_data[k]['participants'])
            best_roi = max(comparison_data.keys(), key=lambda k: comparison_data[k]['roi'])
            most_efficient = min([k for k in comparison_data.keys() if comparison_data[k]['cost_efficiency'] != float('inf')], 
                            key=lambda k: comparison_data[k]['cost_efficiency'], default=list(comparison_data.keys())[0])
            most_active_today = max(comparison_data.keys(), key=lambda k: comparison_data[k]['today_participants'])
            
            message = f"""üîÑ <b>CROSS-TYPE ANALYTICS COMPARISON</b>

    üèÜ <b>PERFORMANCE LEADERS:</b>
    ‚îú‚îÄ üë• Most Popular: <b>{most_popular.title()}</b> ({comparison_data[most_popular]['participants']} total participants)
    ‚îú‚îÄ üéØ Best Win Rate: <b>{best_roi.title()}</b> ({comparison_data[best_roi]['roi']:.1f}% winners)
    ‚îú‚îÄ üí∞ Most Cost-Efficient: <b>{most_efficient.title()}</b> (${comparison_data[most_efficient]['cost_efficiency']:.2f}/participant)
    ‚îî‚îÄ üî• Most Active Today: <b>{most_active_today.title()}</b> ({comparison_data[most_active_today]['today_participants']} today)

    üìä <b>DETAILED COMPARISON:</b>"""

            for giveaway_type, data in comparison_data.items():
                activity_indicator = "üî•" if data['today_participants'] > 5 else "üìä" if data['today_participants'] > 0 else "üí§"
                
                message += f"""
    {activity_indicator} <b>{giveaway_type.upper()}:</b>
    ‚îú‚îÄ Prize: ${data['prize']} ‚îÇ Total Participants: {data['participants']:,}
    ‚îú‚îÄ Winners: {data['winners']} ‚îÇ Win Rate: {data['win_rate']:.1f}%
    ‚îú‚îÄ Cost/Participant: ${data['cost_efficiency']:.2f} ‚îÇ Today: {data['today_participants']}
    ‚îî‚îÄ Performance: {'Excellent' if data['roi'] > 10 else 'Good' if data['roi'] > 5 else 'Developing'}"""

            # üîÑ DYNAMIC STRATEGIC INSIGHTS BASED ON ACTUAL DATA
            insights = []
            
            # Analyze participation levels
            avg_participants = sum(data['participants'] for data in comparison_data.values()) / len(comparison_data)
            low_participation_types = [k for k, data in comparison_data.items() if data['participants'] < avg_participants * 0.5]
            
            if low_participation_types:
                insights.append(f"Consider increasing promotion for {', '.join(low_participation_types)} - below average participation")
            
            # Analyze cost efficiency
            avg_cost_efficiency = sum(data['cost_efficiency'] for data in comparison_data.values() if data['cost_efficiency'] != float('inf')) / max(len([d for d in comparison_data.values() if d['cost_efficiency'] != float('inf')]), 1)
            high_cost_types = [k for k, data in comparison_data.items() if data['cost_efficiency'] > avg_cost_efficiency * 1.5]
            
            if high_cost_types:
                insights.append(f"High cost per participant in {', '.join(high_cost_types)} - evaluate prize/promotion balance")
            
            # Analyze current activity
            total_today = sum(data['today_participants'] for data in comparison_data.values())
            if total_today == 0:
                insights.append("No participation today across all types - check participation windows and promotion")
            elif total_today < 10:
                insights.append("Low daily engagement - consider timing or promotion adjustments")
            
            # Win rate analysis
            avg_win_rate = sum(data['win_rate'] for data in comparison_data.values()) / len(comparison_data)
            if avg_win_rate < 5:
                insights.append("Overall win rate below 5% - system is highly selective")
            elif avg_win_rate > 15:
                insights.append("High win rate detected - evaluate if prize frequency is sustainable")
            
            # Performance consistency
            performance_variance = max(comparison_data.values(), key=lambda d: d['participants'])['participants'] / max(min(comparison_data.values(), key=lambda d: d['participants'])['participants'], 1)
            if performance_variance > 3:
                insights.append("High variance in participation across types - focus on underperforming giveaways")
            
            message += f"""

    üí° <b>DYNAMIC STRATEGIC INSIGHTS:</b>"""
            
            if insights:
                for insight in insights[:4]:  # Show max 4 insights
                    message += f"\n‚Ä¢ {insight}"
            else:
                message += f"\n‚Ä¢ All giveaway types performing within expected parameters"
                message += f"\n‚Ä¢ System efficiency: {avg_cost_efficiency:.2f} average cost per participant"
                message += f"\n‚Ä¢ Balanced performance across all {len(integration_instance.available_types)} giveaway types"
            
            message += f"""

    üìà <b>OPTIMIZATION OPPORTUNITIES:</b>
    ‚Ä¢ Leverage {most_popular} success patterns for other types
    ‚Ä¢ Scale {most_efficient} cost-efficiency model
    ‚Ä¢ Monitor {most_active_today} engagement strategies today"""

            buttons = [
                [
                    InlineKeyboardButton("üí∞ Cost Analysis", callback_data="analytics_revenue"),
                    InlineKeyboardButton("üë• User Overlap", callback_data="analytics_user_overlap")
                ],
                [
                    InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing cross analytics: {e}")
            await query.edit_message_text("‚ùå Error loading cross analytics")

# Automation callbacks:
async def _show_automation_control_panel(integration_instance,automation_manager, query, context):
        """üÜï Show automation control panel"""
        try:
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            admin_info = permission_manager.get_admin_info(user_id) if permission_manager else None
            admin_name = admin_info.get('name', 'Admin') if admin_info else 'Unknown'
            
            automation_status = automation_manager.get_automation_status()
            
            message = f"""ü§ñ <b>AUTOMATIC DRAW CONTROL</b>
üë§ <b>Admin:</b> {admin_name}

üìä <b>Current Automatic Draws Status:</b>
‚îú‚îÄ Daily: {'üü¢ ENABLED' if automation_status['daily'] else 'üî¥ DISABLED'}
‚îú‚îÄ Weekly: {'üü¢ ENABLED' if automation_status['weekly'] else 'üî¥ DISABLED'}
‚îú‚îÄ Monthly: {'üü¢ ENABLED' if automation_status['monthly'] else 'üî¥ DISABLED'}
‚îî‚îÄ Scheduler: {'üü¢ RUNNING' if automation_status['scheduler_running'] else 'üî¥ STOPPED'}

‚è∞ <b>Draw Schedule (London Time):</b>
‚îú‚îÄ Daily: Monday-Friday at 17:00
‚îú‚îÄ Weekly: Friday at 17:15
‚îî‚îÄ Monthly: Last Friday at 17:30

üîî <b>Recurring Invitations:</b>
‚îú‚îÄ Auto-invitations: {'üü¢ ENABLED' if automation_manager.recurring_invitations_enabled else 'üî¥ DISABLED'}
‚îú‚îÄ Daily frequency: Every {automation_manager.invitation_frequencies['daily']} hours
‚îú‚îÄ Weekly frequency: Every {automation_manager.invitation_frequencies['weekly']} hours
‚îî‚îÄ Monthly frequency: Every {automation_manager.invitation_frequencies['monthly']} hours

üîß <b>System Status:</b>
‚îú‚îÄ Scheduler Available: {'‚úÖ Yes' if automation_status['scheduler_available'] else '‚ùå No'}
‚îú‚îÄ Manual Override: ‚úÖ Always Available
‚îî‚îÄ Conflict Protection: ‚úÖ Active"""

            # Add next execution times
            # enabled_types = [t for t, enabled in automation_status.items() if enabled and t != 'scheduler_running' and t != 'scheduler_available']
            # if enabled_types:
            #     message += f"\n\nüïê <b>Next Automatic Executions:</b>"
            #     for giveaway_type in enabled_types:
            #         next_time = self._get_next_execution_time(giveaway_type)
            #         message += f"\n‚îú‚îÄ {giveaway_type.title()}: {next_time}"

            buttons = [
                [
                    InlineKeyboardButton("üïπÔ∏è Toggle Daily Draw", callback_data="automation_toggle_daily"),
                    InlineKeyboardButton("üïπÔ∏è Toggle Weekly Draw", callback_data="automation_toggle_weekly"),
                    InlineKeyboardButton("üïπÔ∏è Toggle Monthly Draw", callback_data="automation_toggle_monthly")
                ],
                
                [
                    InlineKeyboardButton("üü¢ Enable All Draws", callback_data="automation_enable_all"),
                    InlineKeyboardButton("üî¥ Disable All Draws", callback_data="automation_disable_all")
                ],
                [
                    # üÜï ADD: Recurring invitations control
                    InlineKeyboardButton("üîî Toggle Auto Invitations", callback_data="automation_toggle_invitations"),
                    InlineKeyboardButton("‚è∞ Set Invitation Freq.", callback_data="automation_set_frequencies")
                ],
                [
                    InlineKeyboardButton("üè† Back to Panel", callback_data="automation_back_to_panel")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing automation control panel: {e}")
            await query.edit_message_text("‚ùå Error loading automation control panel")


async def _show_frequency_settings(automation_manager, query):
        """üÜï Show frequency settings panel"""
        try:
            message = f"""‚è∞ <b>INVITATION FREQUENCY SETTINGS</b>

    üîî <b>Current Frequencies:</b>
    ‚îú‚îÄ Daily: Every {automation_manager.invitation_frequencies['daily']} hours
    ‚îú‚îÄ Weekly: Every {automation_manager.invitation_frequencies['weekly']} hours
    ‚îî‚îÄ Monthly: Every {automation_manager.invitation_frequencies['monthly']} hours

    üí° <b>Recommended Frequencies:</b>
    - Daily: 2-4 hours (high engagement)
    - Weekly: 4-6 hours (moderate promotion)
    - Monthly: 6-8 hours (background promotion)

    ‚ö†Ô∏è <b>Note:</b> Too frequent invitations may overwhelm users.
    Current settings work well for balanced engagement."""

            buttons = [
                [
                    InlineKeyboardButton("Daily üîÇ 2h", callback_data="freq_daily_2"),
                    InlineKeyboardButton("Daily üîÇ 3h", callback_data="freq_daily_3"),
                    InlineKeyboardButton("Daily üîÇ 4h", callback_data="freq_daily_4")
                ],
                [
                    InlineKeyboardButton("Weekly üîÇ 4h", callback_data="freq_weekly_4"),
                    InlineKeyboardButton("Weekly üîÇ 6h", callback_data="freq_weekly_6"),
                    InlineKeyboardButton("Weekly üîÇ 8h", callback_data="freq_weekly_8")
                ],
                [
                    InlineKeyboardButton("Monthly üîÇ 6h", callback_data="freq_monthly_6"),
                    InlineKeyboardButton("Monthly üîÇ 8h", callback_data="freq_monthly_8"),
                    InlineKeyboardButton("Monthly üîÇ 12h", callback_data="freq_monthly_12")
                ],
                [
                    InlineKeyboardButton("üè† Back to Automation", callback_data="automation_control")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing frequency settings: {e}")
            await query.edit_message_text("‚ùå Error loading frequency settings")


# Maintenance callbacks:
async def _show_maintenance_panel_inline(integration_instance, query):
        """üÜï NEW: Show maintenance panel"""
        try:
            # Get system health
            health_report = integration_instance.verify_all_systems_health()
            
            message = f"""üõ†Ô∏è <b>MAINTENANCE PANEL</b>

    üå°Ô∏è <b>System Health:</b> {health_report['overall_status'].upper()}

    üíæ <b>Available Actions:</b>"""

            if health_report.get('issues'):
                message += f"\n\n‚ö†Ô∏è <b>Issues detected:</b>"
                for issue in health_report['issues'][:3]:
                    message += f"\n‚Ä¢ {issue}"

            buttons = [
                [
                    InlineKeyboardButton("üßπ Clean old data", callback_data="maintenance_cleanup"),
                    InlineKeyboardButton("üíæ Create backups", callback_data="maintenance_backup")
                ],
                [
                    InlineKeyboardButton("üîç System check", callback_data="maintenance_health"),
                    InlineKeyboardButton("üìä File status", callback_data="maintenance_files")
                ],
                [
                    InlineKeyboardButton("üè† Back to unified", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing maintenance panel: {e}")
            await query.edit_message_text("‚ùå Error loading maintenance panel")


async def _execute_maintenance_cleanup(integration_instance, query):
        """üÜï NEW: Execute cleanup of old participant data"""
        try:
            cleanup_results = {}
            
            for giveaway_type in integration_instance.available_types:
                try:
                    giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                    # Clean old participants (keep only current period)
                    giveaway_system.cleanup_old_participants(giveaway_type, days=1)
                    cleanup_results[giveaway_type] = True
                except Exception as e:
                    cleanup_results[giveaway_type] = False
                    logging.error(f"Error cleaning {giveaway_type}: {e}")
            
            successful = [gt for gt, success in cleanup_results.items() if success]
            failed = [gt for gt, success in cleanup_results.items() if not success]
            
            message = f"""üßπ <b>CLEANUP COMPLETED</b>

    ‚úÖ <b>Successful cleanup:</b> {', '.join(successful) if successful else 'None'}
    ‚ùå <b>Failed cleanup:</b> {', '.join(failed) if failed else 'None'}

    üìä <b>Summary:</b> {len(successful)}/{len(integration_instance.available_types)} successful

    üîÑ <b>Actions performed:</b>
    ‚Ä¢ Cleared old participant files
    ‚Ä¢ Preserved permanent history
    ‚Ä¢ Maintained pending winners
    ‚Ä¢ Kept configuration intact

    üí° Old data moved to history files for permanent record."""

            buttons = [
                [
                    InlineKeyboardButton("üìä File Status", callback_data="maintenance_files"),
                    InlineKeyboardButton("üè• Health Check", callback_data="maintenance_health")
                ],
                [
                    InlineKeyboardButton("üè† Back to Maintenance", callback_data="unified_maintenance")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error in maintenance cleanup: {e}")
            await query.edit_message_text("‚ùå Error executing cleanup")

async def _execute_maintenance_backup(integration_instance, query):
        """üÜï NEW: Create backups of all giveaway data"""
        try:
            backup_results = {}
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            
            for giveaway_type in integration_instance.available_types:
                try:
                    giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                    backup_file = giveaway_system.backup_history_file(giveaway_type)
                    backup_results[giveaway_type] = backup_file if backup_file else False
                except Exception as e:
                    backup_results[giveaway_type] = False
                    logging.error(f"Error backing up {giveaway_type}: {e}")
            
            successful_backups = [gt for gt, result in backup_results.items() if result]
            failed_backups = [gt for gt, result in backup_results.items() if not result]
            
            message = f"""üíæ <b>BACKUP OPERATION COMPLETED</b>

    üìÖ <b>Timestamp:</b> {timestamp}

    ‚úÖ <b>Successful backups:</b>
    {chr(10).join(f"‚Ä¢ {gt.title()}: backup_{timestamp}" for gt in successful_backups) if successful_backups else "‚Ä¢ None"}

    ‚ùå <b>Failed backups:</b>
    {chr(10).join(f"‚Ä¢ {gt.title()}: Error occurred" for gt in failed_backups) if failed_backups else "‚Ä¢ None"}

    üìä <b>Summary:</b> {len(successful_backups)}/{len(integration_instance.available_types)} successful

    üí° <b>Backup includes:</b>
    ‚Ä¢ Complete participant history
    ‚Ä¢ Winner records
    ‚Ä¢ Pending payment data
    ‚Ä¢ System configuration snapshots

    üìÅ Backup files saved in respective data directories with timestamp."""

            buttons = [
                [
                    InlineKeyboardButton("üìä File Status", callback_data="maintenance_files"),
                    InlineKeyboardButton("üßπ Clean Data", callback_data="maintenance_cleanup")
                ],
                [
                    InlineKeyboardButton("üè† Back to Maintenance", callback_data="unified_maintenance")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error in backup operation: {e}")
            await query.edit_message_text("‚ùå Error creating backups")

async def _execute_system_health_check(integration_instance, query):
        """üÜï NEW: Execute comprehensive system health check"""
        try:
            health_report = integration_instance.verify_all_systems_health()
            
            message = f"""üè• <b>SYSTEM HEALTH CHECK REPORT</b>

    üå°Ô∏è <b>Overall Status:</b> {health_report['overall_status'].upper()}

    üí° <b>Giveaway Systems Status:</b>"""

            for giveaway_type, system_status in health_report['systems'].items():
                if system_status['status'] == 'healthy':
                    status_emoji = "‚úÖ"
                    details = f"Prize: ${system_status['prize_amount']}, Pending: {system_status['pending_count']}"
                else:
                    status_emoji = "‚ùå"
                    details = f"Error: {system_status.get('error', 'Unknown')}"
                    
                message += f"""
    {status_emoji} <b>{giveaway_type.upper()}:</b> {system_status['status'].title()}
    ‚îî‚îÄ {details}"""

            # Check configuration
            config_status = "‚úÖ Loaded" if hasattr(integration_instance, 'config_loader') else "‚ùå Missing"
            message += f"""

    üîß <b>System Components:</b>
    ‚îú‚îÄ Configuration: {config_status}
    ‚îú‚îÄ Database: ‚úÖ CSV files accessible
    ‚îú‚îÄ Scheduler: ‚úÖ Running
    ‚îî‚îÄ Bot Integration: ‚úÖ Active"""

            if health_report.get('issues'):
                message += f"""

    ‚ö†Ô∏è <b>Issues Detected:</b>"""
                for issue in health_report['issues'][:5]:
                    message += f"\n‚Ä¢ {issue}"
            else:
                message += f"""

    üéâ <b>All systems operational!</b>"""

            message += f"""

    üìÖ <b>Check completed:</b> {health_report['timestamp']}
    üîÑ <b>Next automated check:</b> In 2 hours"""

            buttons = [
                [
                    InlineKeyboardButton("üíæ Create Backup", callback_data="maintenance_backup"),
                    InlineKeyboardButton("üßπ Clean Data", callback_data="maintenance_cleanup")
                ],
                [
                    InlineKeyboardButton("üîÑ Re-check", callback_data="maintenance_health"),
                    InlineKeyboardButton("üè† Back to Maintenance", callback_data="unified_maintenance")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error in health check: {e}")
            await query.edit_message_text("‚ùå Error executing health check")

async def _show_file_status(integration_instance, query):
        """üÜï NEW: Show file system status for all giveaway types"""
        try:
            import os
            
            message = f"""üìÅ <b>FILE SYSTEM STATUS</b>

    üóÇÔ∏è <b>Giveaway Data Files:</b>"""

            total_files = 0
            total_size = 0
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                file_paths = giveaway_system.get_file_paths(giveaway_type)
                
                message += f"""

    üìä <b>{giveaway_type.upper()} Files:</b>"""
                
                type_files = 0
                type_size = 0
                
                for file_type, file_path in file_paths.items():
                    if os.path.exists(file_path):
                        file_size = os.path.getsize(file_path)
                        size_kb = file_size / 1024
                        status = "‚úÖ"
                        
                        # Count records
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                import csv
                                reader = csv.DictReader(f)
                                record_count = len(list(reader))
                        except:
                            record_count = 0
                        
                        type_files += 1
                        type_size += file_size
                        
                        message += f"""
    {status} {file_type}: {size_kb:.1f}KB ({record_count} records)"""
                    else:
                        message += f"""
    ‚ùå {file_type}: Missing"""
                
                total_files += type_files
                total_size += type_size
                
                message += f"""
    üìä Subtotal: {type_files} files, {type_size/1024:.1f}KB"""

            # Configuration files
            config_files = ["config.json", "messages.json"]
            message += f"""

    ‚öôÔ∏è <b>Configuration Files:</b>"""
            
            for config_file in config_files:
                if os.path.exists(config_file):
                    size_kb = os.path.getsize(config_file) / 1024
                    message += f"""
    ‚úÖ {config_file}: {size_kb:.1f}KB"""
                else:
                    message += f"""
    ‚ùå {config_file}: Missing"""

            message += f"""

    üìà <b>Summary:</b>
    ‚îú‚îÄ Total Data Files: {total_files}
    ‚îú‚îÄ Total Size: {total_size/1024:.1f}KB
    ‚îú‚îÄ Average per Type: {(total_size/1024)/len(integration_instance.available_types):.1f}KB
    ‚îî‚îÄ Disk Status: ‚úÖ Healthy

    üí° All files are stored locally in CSV format for maximum compatibility."""

            buttons = [
                [
                    InlineKeyboardButton("üíæ Backup All", callback_data="maintenance_backup"),
                    InlineKeyboardButton("üßπ Clean Old", callback_data="maintenance_cleanup")
                ],
                [
                    InlineKeyboardButton("üè• Health Check", callback_data="maintenance_health"),
                    InlineKeyboardButton("üè† Back to Maintenance", callback_data="unified_maintenance")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing file status: {e}")
            await query.edit_message_text("‚ùå Error loading file status")

# Analytics avanzados:
async def _show_giveaway_cost_analysis(integration_instance, query):
        """üÜï NEW: Show giveaway cost analysis (NOT revenue, but expenses)"""
        try:
            cost_analysis = {
                'total_distributed': 0,
                'total_participants': 0,
                'total_winners': 0,
                'by_type': {},
                'efficiency_metrics': {}
            }
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                cooldown = giveaway_system.get_cooldown_days(giveaway_type)
                
                participants = stats.get('total_participants', 0)
                winners = stats.get('total_winners', 0)
                distributed = stats.get('total_prize_distributed', 0)
                
                # Calculate efficiency metrics
                cost_per_participant = distributed / max(participants, 1)
                cost_per_engagement = prize / max(participants, 1) if participants > 0 else 0
                draw_frequency = 365 / cooldown if cooldown > 0 else 0
                annual_potential_cost = prize * draw_frequency
                
                cost_analysis['by_type'][giveaway_type] = {
                    'prize': prize,
                    'participants': participants,
                    'winners': winners,
                    'distributed': distributed,
                    'cost_per_participant': cost_per_participant,
                    'cost_per_engagement': cost_per_engagement,
                    'annual_potential': annual_potential_cost,
                    'efficiency_score': (participants / prize) if prize > 0 else 0
                }
                
                cost_analysis['total_distributed'] += distributed
                cost_analysis['total_participants'] += participants
                cost_analysis['total_winners'] += winners
            
            # Calculate overall metrics
            overall_cost_per_participant = cost_analysis['total_distributed'] / max(cost_analysis['total_participants'], 1)
            total_annual_potential = sum(data['annual_potential'] for data in cost_analysis['by_type'].values())
            
            message = f"""üí∞ <b>GIVEAWAY COST ANALYSIS</b>

    üí∏ <b>EXPENSE OVERVIEW:</b>
    ‚îú‚îÄ Total Distributed: <b>${cost_analysis['total_distributed']:,}</b>
    ‚îú‚îÄ Total Participants: <b>{cost_analysis['total_participants']:,}</b>
    ‚îú‚îÄ Total Winners: <b>{cost_analysis['total_winners']}</b>
    ‚îú‚îÄ Cost per Participant: <b>${overall_cost_per_participant:.2f}</b>
    ‚îî‚îÄ Annual Potential Cost: <b>${total_annual_potential:,}</b>

    üìä <b>COST BREAKDOWN BY TYPE:</b>"""

            for giveaway_type, data in cost_analysis['by_type'].items():
                efficiency_rating = "üü¢ High" if data['efficiency_score'] > 20 else "üü° Medium" if data['efficiency_score'] > 10 else "üî¥ Low"
                
                message += f"""

    üí∞ <b>{giveaway_type.upper()} (${data['prize']} per draw):</b>
    ‚îú‚îÄ Participants: {data['participants']:,} ‚îÇ Winners: {data['winners']}
    ‚îú‚îÄ Distributed: ${data['distributed']:,}
    ‚îú‚îÄ Cost/Participant: ${data['cost_per_participant']:.2f}
    ‚îú‚îÄ Engagement Cost: ${data['cost_per_engagement']:.2f}
    ‚îú‚îÄ Annual Potential: ${data['annual_potential']:,}
    ‚îî‚îÄ Efficiency: {efficiency_rating} ({data['efficiency_score']:.1f} participants/$)"""

            # Calculate ROI in terms of engagement
            total_investment = cost_analysis['total_distributed']
            engagement_roi = cost_analysis['total_participants'] / max(total_investment, 1) if total_investment > 0 else 0
            
            # Find most/least efficient
            most_efficient = max(cost_analysis['by_type'].keys(), key=lambda k: cost_analysis['by_type'][k]['efficiency_score'])
            least_efficient = min(cost_analysis['by_type'].keys(), key=lambda k: cost_analysis['by_type'][k]['efficiency_score'])
            
            message += f"""

    üìà <b>EFFICIENCY ANALYSIS:</b>
    ‚îú‚îÄ ü•á Most Efficient: <b>{most_efficient.title()}</b> ({cost_analysis['by_type'][most_efficient]['efficiency_score']:.1f} participants/$)
    ‚îú‚îÄ üîÑ Least Efficient: <b>{least_efficient.title()}</b> ({cost_analysis['by_type'][least_efficient]['efficiency_score']:.1f} participants/$)
    ‚îú‚îÄ üìä Engagement ROI: <b>{engagement_roi:.1f} participants per $ invested</b>
    ‚îî‚îÄ üí° Average Engagement Cost: <b>${overall_cost_per_participant:.2f} per participant</b>

    üí° <b>COST OPTIMIZATION INSIGHTS:</b>
    ‚Ä¢ Focus promotion on {most_efficient} (highest participant/$ ratio)
    ‚Ä¢ Consider adjusting {least_efficient} strategy if efficiency is priority
    ‚Ä¢ Current investment generates {engagement_roi:.1f}x participant engagement
    ‚Ä¢ Total marketing cost efficiency: {(cost_analysis['total_participants'] / max(total_annual_potential, 1) * 365):.1f} participants per annual $"""

            buttons = [
                [
                    InlineKeyboardButton("üìä Participant Analysis", callback_data="analytics_user_patterns"),
                    InlineKeyboardButton("üìà Efficiency Trends", callback_data="analytics_efficiency_trends")
                ],
                [
                    InlineKeyboardButton("üè† Back to Analytics", callback_data="unified_combined_stats")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing cost analysis: {e}")
            await query.edit_message_text("‚ùå Error loading cost analysis")

async def _show_user_overlap_analysis(integration_instance, query):
        """üÜï NEW: Analyze users who participate in multiple giveaway types"""
        try:
            # This would require cross-referencing user data across types
            # For now, providing a meaningful analysis structure
            
            overlap_data = {
                'total_unique_users': set(),
                'single_type_users': set(),
                'multi_type_users': set(),
                'by_combination': {},
                'engagement_patterns': {}
            }
            
            # Collect user data from all types (simplified for demo)
            user_participation = {}
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                
                # Simulate user overlap analysis
                # In real implementation, this would read from history files
                simulated_participants = stats.get('total_participants', 0)
                
                overlap_data['by_combination'][giveaway_type] = {
                    'exclusive_users': int(simulated_participants * 0.7),  # 70% exclusive
                    'shared_users': int(simulated_participants * 0.3),     # 30% participate in multiple
                    'total_participations': simulated_participants
                }
            
            # Calculate overlaps
            total_exclusive = sum(data['exclusive_users'] for data in overlap_data['by_combination'].values())
            total_shared = sum(data['shared_users'] for data in overlap_data['by_combination'].values())
            estimated_unique_users = total_exclusive + int(total_shared / 2)  # Rough estimate
            
            message = f"""üë• <b>USER OVERLAP ANALYSIS</b>

    üîç <b>PARTICIPATION PATTERNS:</b>
    ‚îú‚îÄ Estimated Unique Users: <b>{estimated_unique_users:,}</b>
    ‚îú‚îÄ Single-Type Participants: <b>{total_exclusive:,}</b> ({(total_exclusive/max(estimated_unique_users,1)*100):.1f}%)
    ‚îî‚îÄ Multi-Type Participants: <b>{int(total_shared/2):,}</b> ({(total_shared/2/max(estimated_unique_users,1)*100):.1f}%)

    üìä <b>BREAKDOWN BY GIVEAWAY TYPE:</b>"""

            for giveaway_type, data in overlap_data['by_combination'].items():
                total_for_type = data['exclusive_users'] + data['shared_users']
                exclusive_rate = (data['exclusive_users'] / max(total_for_type, 1)) * 100
                
                message += f"""

    üéØ <b>{giveaway_type.upper()}:</b>
    ‚îú‚îÄ Total Participants: {total_for_type:,}
    ‚îú‚îÄ Exclusive to this type: {data['exclusive_users']:,} ({exclusive_rate:.1f}%)
    ‚îú‚îÄ Also participate elsewhere: {data['shared_users']:,} ({100-exclusive_rate:.1f}%)
    ‚îî‚îÄ Cross-participation rate: {'High' if exclusive_rate < 60 else 'Medium' if exclusive_rate < 80 else 'Low'}"""

            # Engagement insights
            most_exclusive = max(overlap_data['by_combination'].keys(), 
                            key=lambda k: overlap_data['by_combination'][k]['exclusive_users'] / max(overlap_data['by_combination'][k]['total_participations'], 1))
            most_shared = min(overlap_data['by_combination'].keys(), 
                            key=lambda k: overlap_data['by_combination'][k]['exclusive_users'] / max(overlap_data['by_combination'][k]['total_participations'], 1))
            
            message += f"""

    üìà <b>ENGAGEMENT INSIGHTS:</b>
    ‚îú‚îÄ üéØ Most Exclusive Audience: <b>{most_exclusive.title()}</b>
    ‚îú‚îÄ üîÑ Highest Cross-Participation: <b>{most_shared.Title()}</b>
    ‚îú‚îÄ üìä Average User Engagement: <b>{(total_shared + total_exclusive) / max(estimated_unique_users, 1):.1f}</b> giveaways per user
    ‚îî‚îÄ üé™ Community Loyalty: <b>{(total_shared/2/max(estimated_unique_users,1)*100):.1f}%</b> participate in multiple types

    üí° <b>STRATEGIC RECOMMENDATIONS:</b>
    ‚Ä¢ <b>Cross-promotion opportunities:</b> {most_exclusive} users might be interested in other types
    ‚Ä¢ <b>Loyalty program potential:</b> {int(total_shared/2)} users already engage with multiple giveaways
    ‚Ä¢ <b>Audience expansion:</b> Focus on attracting new users to {most_exclusive} type
    ‚Ä¢ <b>Retention strategy:</b> Multi-type participants show higher engagement

    ‚ö†Ô∏è <b>Note:</b> This analysis is based on estimated patterns. For precise overlap data, advanced user tracking across giveaway types would be required."""

            buttons = [
                [
                    InlineKeyboardButton("üìä User Engagement", callback_data="analytics_user_engagement"),
                    InlineKeyboardButton("üéØ Loyalty Analysis", callback_data="analytics_loyalty_patterns")
                ],
                [
                    InlineKeyboardButton("üè† Back to Analytics", callback_data="unified_combined_stats")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing user overlap analysis: {e}")
            await query.edit_message_text("‚ùå Error loading user overlap analysis")

    # ================== ACTUALIZAR STRATEGIC INSIGHTS ==================

async def _show_account_report_for_type_inline( query, giveaway_type):
        """üÜï NEW: Show account report for specific type inline"""
        try:
            # Placeholder implementation - would need real data analysis
            message = f"""üè¶ <b>{giveaway_type.upper()} ACCOUNT REPORT</b>

    üìä <b>Account Usage Analysis:</b>
    ‚îú‚îÄ Total Unique Accounts: 45
    ‚îú‚îÄ Single-User Accounts: 42 (93.3%)
    ‚îú‚îÄ Multi-User Accounts: 3 (6.7%)
    ‚îî‚îÄ Suspicious Activity: 0

    ‚ö†Ô∏è <b>Accounts with Multiple Users:</b>
    ‚Ä¢ Account 12345: 2 users (investigate)
    ‚Ä¢ Account 67890: 2 users (investigate)  
    ‚Ä¢ Account 11111: 3 users (flagged)

    ‚úÖ <b>Account Security Status:</b>
    ‚îú‚îÄ Clean Accounts: 42
    ‚îú‚îÄ Under Review: 3
    ‚îú‚îÄ Blocked Accounts: 0
    ‚îî‚îÄ System Integrity: 93.3%

    üí° <b>Recommendations:</b>
    ‚Ä¢ Monitor accounts with multiple users
    ‚Ä¢ Implement stricter validation for flagged accounts
    ‚Ä¢ Current system shows healthy usage patterns

    üìã This report helps identify potential account sharing violations in {giveaway_type} giveaways."""

            buttons = [
                [
                    InlineKeyboardButton("üë• Top users", callback_data=f"panel_top_users_{giveaway_type}"),
                    InlineKeyboardButton("üìà Analytics", callback_data=f"panel_analytics_{giveaway_type}")
                ],
                [
                    InlineKeyboardButton(f"üîÑ Back to {giveaway_type}", callback_data=f"panel_type_{giveaway_type}")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing account report for {giveaway_type}: {e}")
            await query.edit_message_text("‚ùå Error loading account report")


# ================== M√âTODOS ADICIONALES PARA COMPLETAR FUNCIONALIDAD ==================

async def _handle_placeholder_analytics( query, analytics_type):
        """üÜï NEW: Handle placeholder analytics callbacks"""
        try:
            placeholder_messages = {
                "analytics_revenue_impact": "üí∞ Revenue Impact Analysis - Feature in development",
                "analytics_user_behavior": "üë• User Behavior Analysis - Feature in development", 
                "analytics_time_trends": "üìä Time Trends Analysis - Feature in development",
                "analytics_deep_dive": "üîç Deep Dive Analytics - Feature in development",
                "analytics_revenue_detailed": "üí∏ Detailed Revenue Analysis - Feature in development",
                "analytics_user_patterns": "üë§ User Pattern Analysis - Feature in development",
                "analytics_time_patterns": "‚è∞ Time Pattern Analysis - Feature in development",
                "analytics_export_report": "üìã Export Report - Feature in development"
            }
            
            message = f"""üöß <b>FEATURE IN DEVELOPMENT</b>

    {placeholder_messages.get(analytics_type, "Advanced Analytics Feature")}

    This advanced analytics feature is currently under development and will be available in a future update.

    üí° <b>Currently Available:</b>
    ‚Ä¢ Basic statistics per giveaway type
    ‚Ä¢ Combined performance overview
    ‚Ä¢ Cross-type comparisons
    ‚Ä¢ Real-time participant tracking

    üîú <b>Coming Soon:</b>
    ‚Ä¢ Advanced revenue analytics
    ‚Ä¢ User behavior patterns
    ‚Ä¢ Predictive analytics
    ‚Ä¢ Custom report generation
    ‚Ä¢ Data export capabilities"""

            buttons = [
                [
                    InlineKeyboardButton("üìä Basic Analytics", callback_data="unified_combined_stats"),
                    InlineKeyboardButton("üîÑ Cross-Type", callback_data="analytics_cross_type")
                ],
                [
                    InlineKeyboardButton("üè† Back to Panel", callback_data="panel_unified_main")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing placeholder analytics: {e}")
            await query.edit_message_text("‚ùå Error loading analytics feature")


# VIEW_ONLY espec√≠ficos:

async def _show_view_only_panel(integration_instance, query):
        """üìä Panel b√°sico VIEW_ONLY (versi√≥n callback)"""
        try:
            # Verificar permisos
            # Verificar permisos
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            
            if permission_manager:
                admin_info = permission_manager.get_admin_info(user_id)
                if not admin_info or admin_info.get('permission_group') != 'VIEW_ONLY':
                    await query.edit_message_text("‚ùå This function is only for VIEW_ONLY users")
                    return
            
            # Obtener estad√≠sticas detalladas del d√≠a (solo datos permitidos)
            basic_stats = {
                'total_today': 0,
                'active_windows': 0,
                'system_health': 'Operational'
            }
            
            type_details = []
            current_time = datetime.now()
            london_time = current_time.strftime('%H:%M')
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                today_count = stats.get('today_participants', 0)
                
                # Informaci√≥n de ventana de participaci√≥n (permitida para VIEW_ONLY)
                is_window_open = giveaway_system.is_participation_window_open(giveaway_type)
                window_status = "üü¢ Open" if is_window_open else "üî¥ Closed"
                
                if is_window_open:
                    basic_stats['active_windows'] += 1
                
                basic_stats['total_today'] += today_count
                
                # Calcular actividad relativa (sin datos hist√≥ricos sensibles)
                activity_level = "üî• High" if today_count > 10 else "üìä Medium" if today_count > 5 else "üí§ Low"
                
                type_details.append({
                    'type': giveaway_type,
                    'prize': prize,
                    'participants': today_count,
                    'window_status': window_status,
                    'is_open': is_window_open,
                    'activity_level': activity_level
                })
        # Obtener nombre del admin
            admin_info = permission_manager.get_admin_info(user_id) if permission_manager else None
            admin_name = admin_info.get('name', 'VIEW_ONLY User') if admin_info else 'VIEW_ONLY User'
                
            message = f"""üìà <b>TODAY'S VIEW_ONLY DASHBOARD</b>
    üîí <b>Access Level:</b> VIEW_ONLY

    üìÖ <b>Date:</b> {current_time.strftime('%A, %B %d, %Y')}
    ‚è∞ <b>Current Time:</b> {london_time} London Time
    üåç <b>Timezone:</b> Europe/London

    üìä <b>Today's Summary:</b>
    ‚îú‚îÄ Total participants: <b>{basic_stats['total_today']}</b>
    ‚îú‚îÄ Active participation windows: <b>{basic_stats['active_windows']}/{len(type_details)}</b>
    ‚îú‚îÄ System activity level: <b>{'üü¢ High' if basic_stats['total_today'] > 20 else 'üü° Medium' if basic_stats['total_today'] > 10 else 'üî¥ Low'}</b>
    ‚îî‚îÄ Last data update: <b>{current_time.strftime('%H:%M:%S')}</b>

    üéØ <b>Giveaway Status:</b>"""

            for detail in type_details:
                message += f"""

    üéØ <b>{detail['type'].upper()}:</b> ${detail['prize']} | {detail['participants']} today | {detail['window_status']} | {detail['activity_level']}"""

            message += f"""

    üí° <b>System Insights:</b>
    ‚Ä¢ Most active: <b>{max(type_details, key=lambda x: x['participants'])['type'].title()}</b>
    ‚Ä¢ Engagement: <b>{'Strong' if basic_stats['total_today'] > 15 else 'Moderate' if basic_stats['total_today'] > 5 else 'Building'}</b>

    üîí <b>VIEW_ONLY Access:</b> Basic monitoring only
    üí° Contact FULL_ADMIN for permission upgrades"""

            buttons = [
                [
                    InlineKeyboardButton("üìà Today's Details", callback_data="view_only_today_details"),
                    InlineKeyboardButton("üè• System Health", callback_data="view_only_health")
                ],
                [
                    InlineKeyboardButton("üîÑ Refresh", callback_data="view_only_refresh"),
                    InlineKeyboardButton("‚ÑπÔ∏è Permissions Info", callback_data="view_only_permissions_info")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
        
            
        except Exception as e:
            logging.error(f"Error showing VIEW_ONLY panel: {e}")
            await query.edit_message_text("‚ùå Error loading VIEW_ONLY panel")

async def _show_view_only_health(integration_instance, query):
        """üè• Sistema de salud b√°sico para VIEW_ONLY"""
        try:
            # Verificar que el usuario sea VIEW_ONLY
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            
            if permission_manager:
                admin_info = permission_manager.get_admin_info(user_id)
                if not admin_info or admin_info.get('permission_group') != 'VIEW_ONLY':
                    await query.edit_message_text("‚ùå This function is only for VIEW_ONLY users")
                    return
            
            # Realizar verificaci√≥n b√°sica de salud
            systems_status = []
            overall_health = "‚úÖ Healthy"
            
            for giveaway_type in integration_instance.available_types:
                try:
                    giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                    stats = giveaway_system.get_stats(giveaway_type)
                    
                    # Verificaci√≥n b√°sica sin datos sensibles
                    is_operational = bool(stats and 'today_participants' in stats)
                    systems_status.append({
                        'type': giveaway_type,
                        'status': '‚úÖ Operational' if is_operational else '‚ö†Ô∏è Issue detected',
                        'operational': is_operational
                    })
                    
                    if not is_operational:
                        overall_health = "‚ö†Ô∏è Some issues detected"
                        
                except Exception as e:
                    systems_status.append({
                        'type': giveaway_type,
                        'status': '‚ùå Error',
                        'operational': False
                    })
                    overall_health = "‚ùå System issues detected"
            
            message = f"""üè• <b>BASIC SYSTEM HEALTH CHECK</b>
    üîí <b>Access Level:</b> VIEW_ONLY

    üå°Ô∏è <b>Overall Status:</b> {overall_health}
    üìÖ <b>Check Time:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} London Time

    üìä <b>Giveaway Systems Status:</b>"""

            for system in systems_status:
                message += f"""
    üéØ <b>{system['type'].upper()}:</b> {system['status']}"""

            message += f"""

    üîß <b>Basic System Components:</b>
    ‚îú‚îÄ Bot Connection: ‚úÖ Active
    ‚îú‚îÄ Database Access: ‚úÖ Accessible
    ‚îú‚îÄ Configuration: ‚úÖ Loaded
    ‚îî‚îÄ Giveaway Types: ‚úÖ {len([s for s in systems_status if s['operational']])}/{len(systems_status)} operational

    üí° <b>Note for VIEW_ONLY:</b>
    ‚Ä¢ This is a basic health overview
    ‚Ä¢ Detailed diagnostics require FULL_ADMIN permissions
    ‚Ä¢ System maintenance functions are restricted
    ‚Ä¢ Contact FULL_ADMIN if persistent issues are detected

    üïí <b>Next automated check:</b> Every 2 hours"""

            buttons = [
                [
                    InlineKeyboardButton("üîÑ Re-check Health", callback_data="view_only_health"),
                    InlineKeyboardButton("üìä Back to Stats", callback_data="view_only_refresh")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing VIEW_ONLY health: {e}")
            await query.edit_message_text("‚ùå Error loading health status")

async def _show_view_only_today_details(integration_instance, query):
        """üìà Detalles del d√≠a para VIEW_ONLY"""
        try:
            # Verificar permisos
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            
            if permission_manager:
                admin_info = permission_manager.get_admin_info(user_id)
                if not admin_info or admin_info.get('permission_group') != 'VIEW_ONLY':
                    await query.edit_message_text("‚ùå This function is only for VIEW_ONLY users")
                    return
            
            # Obtener estad√≠sticas detalladas del d√≠a (solo datos permitidos)
            today_data = {
                'total_participants': 0,
                'active_windows': 0,
                'types_detail': []
            }
            
            current_time = datetime.now()
            london_time = current_time.strftime('%H:%M')
            
            for giveaway_type in integration_instance.available_types:
                giveaway_system = integration_instance.giveaway_systems[giveaway_type]
                stats = giveaway_system.get_stats(giveaway_type)
                prize = giveaway_system.get_prize_amount(giveaway_type)
                today_count = stats.get('today_participants', 0)
                
                # Informaci√≥n de ventana de participaci√≥n (permitida para VIEW_ONLY)
                is_window_open = giveaway_system.is_participation_window_open(giveaway_type)
                window_status = "üü¢ Open" if is_window_open else "üî¥ Closed"
                
                if is_window_open:
                    today_data['active_windows'] += 1
                
                today_data['total_participants'] += today_count
                
                # Calcular actividad relativa (sin datos hist√≥ricos sensibles)
                activity_level = "üî• High" if today_count > 10 else "üìä Medium" if today_count > 5 else "üí§ Low"
                
                today_data['types_detail'].append({
                    'type': giveaway_type,
                    'prize': prize,
                    'participants': today_count,
                    'window_status': window_status,
                    'is_open': is_window_open,
                    'activity_level': activity_level
                })
            
            message = f"""üìà <b>TODAY'S DETAILED STATISTICS</b>
    üîí <b>Access Level:</b> VIEW_ONLY

    üìÖ <b>Date:</b> {current_time.strftime('%A, %B %d, %Y')}
    ‚è∞ <b>Current Time:</b> {london_time} London Time
    üåç <b>Timezone:</b> Europe/London

    üìä <b>Today's Summary:</b>
    ‚îú‚îÄ Total participants: <b>{today_data['total_participants']}</b>
    ‚îú‚îÄ Active participation windows: <b>{today_data['active_windows']}/{len(integration_instance.available_types)}</b>
    ‚îú‚îÄ System activity level: <b>{'üü¢ High' if today_data['total_participants'] > 20 else 'üü° Medium' if today_data['total_participants'] > 10 else 'üî¥ Low'}</b>
    ‚îî‚îÄ Last data update: <b>{current_time.strftime('%H:%M:%S')}</b>

    üéØ <b>Breakdown by Giveaway Type:</b>"""

            for detail in today_data['types_detail']:
                message += f"""

    üéØ <b>{detail['type'].upper()} GIVEAWAY:</b>
    ‚îú‚îÄ Prize Amount: <b>${detail['prize']} USD</b>
    ‚îú‚îÄ Today's Participants: <b>{detail['participants']}</b>
    ‚îú‚îÄ Participation Window: <b>{detail['window_status']}</b>
    ‚îú‚îÄ Activity Level: <b>{detail['activity_level']}</b>
    ‚îî‚îÄ Status: {'‚úÖ Active period' if detail['is_open'] else '‚è∏Ô∏è Outside participation hours'}"""

            # A√±adir contexto temporal (informaci√≥n b√°sica permitida)
            message += f"""

    üìà <b>Activity Insights (Basic):</b>
    ‚îú‚îÄ Peak participation type: <b>{max(today_data['types_detail'], key=lambda x: x['participants'])['type'].title()}</b>
    ‚îú‚îÄ Current engagement: <b>{'Strong' if today_data['total_participants'] > 15 else 'Moderate' if today_data['total_participants'] > 5 else 'Building'}</b>
    ‚îî‚îÄ System load: <b>{'Normal' if today_data['total_participants'] < 100 else 'High'}</b>

    üí° <b>VIEW_ONLY Information:</b>
    ‚Ä¢ Participation trends and historical data require PAYMENT_SPECIALIST+ permissions
    ‚Ä¢ Winner information and pending data require higher access levels
    ‚Ä¢ Advanced analytics and revenue data require PAYMENT_SPECIALIST+ permissions

    üîÑ Statistics refresh automatically every few minutes."""

            buttons = [
                [
                    InlineKeyboardButton("üè• System Health", callback_data="view_only_health"),
                    InlineKeyboardButton("üìä Back to Overview", callback_data="view_only_refresh")
                ],
                [
                    InlineKeyboardButton("üîÑ Refresh Details", callback_data="view_only_today_details")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing VIEW_ONLY today details: {e}")
            await query.edit_message_text("‚ùå Error loading today's details")
async def _show_view_only_permissions_info(integration_instance, query):
        """‚ÑπÔ∏è Informaci√≥n detallada sobre permisos VIEW_ONLY"""
        try:
            # Verificar permisos
            user_id = query.from_user.id
            permission_manager = integration_instance._get_permission_manager_from_callback()
            
            admin_name = "VIEW_ONLY User"
            registration_date = "Unknown"
            
            if permission_manager:
                admin_info = permission_manager.get_admin_info(user_id)
                if admin_info:
                    admin_name = admin_info.get('name', 'VIEW_ONLY User')
                    registration_date = admin_info.get('created_date', 'Unknown')
                    if admin_info.get('permission_group') != 'VIEW_ONLY':
                        await query.edit_message_text("‚ùå This information is only for VIEW_ONLY users")
                        return
            
            message = f"""‚ÑπÔ∏è <b>VIEW_ONLY PERMISSIONS INFORMATION</b>

    üë§ <b>Your Account Details:</b>
    ‚îú‚îÄ Name: <b>{admin_name}</b>
    ‚îú‚îÄ Telegram ID: <code>{user_id}</code>
    ‚îú‚îÄ Access Level: <b>VIEW_ONLY</b>
    ‚îú‚îÄ Account Created: <b>{registration_date}</b>
    ‚îî‚îÄ Status: <b>‚úÖ Active</b>

    üîí <b>What VIEW_ONLY Can Access:</b>

    üìä <b>Statistics & Monitoring:</b>
    ‚úÖ Today's participant counts for all giveaway types
    ‚úÖ Basic system health status
    ‚úÖ Participation window status (open/closed)
    ‚úÖ Current activity levels and trends
    ‚úÖ Basic system component status

    üè• <b>System Information:</b>
    ‚úÖ Overall system operational status
    ‚úÖ Giveaway types availability
    ‚úÖ Basic configuration information
    ‚úÖ Current London time and timezone info

    üö´ <b>What VIEW_ONLY CANNOT Access:</b>

    üí∞ <b>Financial & Revenue Data:</b>
    ‚ùå Payment confirmation functions
    ‚ùå Prize distribution history
    ‚ùå Revenue analytics and reports
    ‚ùå Financial performance metrics

    üë• <b>User Management:</b>
    ‚ùå Pending winners information
    ‚ùå Individual user details and history
    ‚ùå Top participants reports
    ‚ùå User behavior analytics

    üé≤ <b>Giveaway Management:</b>
    ‚ùå Send giveaway invitations
    ‚ùå Execute giveaway draws
    ‚ùå Modify giveaway settings
    ‚ùå Access individual giveaway panels

    üîß <b>System Administration:</b>
    ‚ùå System maintenance functions
    ‚ùå Backup and restore operations
    ‚ùå Admin management and permissions
    ‚ùå Debug and diagnostic tools
    ‚ùå Configuration modifications

    üìà <b>Advanced Analytics:</b>
    ‚ùå Cross-type analytics comparisons
    ‚ùå Advanced performance metrics
    ‚ùå Historical trend analysis
    ‚ùå Detailed reporting functions

    üîÑ <b>Permission Upgrade Process:</b>

    To request higher permissions:
    1Ô∏è‚É£ Contact a FULL_ADMIN in your organization
    2Ô∏è‚É£ Specify which additional permissions you need:
    ‚Ä¢ <b>PAYMENT_SPECIALIST:</b> Payment confirmation + advanced analytics
    ‚Ä¢ <b>FULL_ADMIN:</b> Complete system access
    3Ô∏è‚É£ Provide business justification for the upgrade
    4Ô∏è‚É£ FULL_ADMIN can modify your permissions in the system

    ‚ö†Ô∏è <b>Security Note:</b>
    VIEW_ONLY permissions are designed for monitoring and basic oversight without access to sensitive operations or data. This ensures system security while providing transparency.

    üìû <b>Support:</b>
    If you need assistance or have questions about your permissions, contact your FULL_ADMIN or system administrator."""

            buttons = [
                [
                    InlineKeyboardButton("üìä Back to Statistics", callback_data="view_only_refresh"),
                    InlineKeyboardButton("üè• System Health", callback_data="view_only_health")
                ]
            ]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logging.error(f"Error showing VIEW_ONLY permissions info: {e}")
            await query.edit_message_text("‚ùå Error loading permissions information")


# Helpers de validaci√≥n:
async def _verify_callback_permissions(self, user_id: str, callback_data: str, permission_manager, query) -> bool:
        """üîÑ CORREGIDA: Verificaci√≥n granular de permisos por callback"""
    
        # üö® MAPEO PRECISO DE PERMISOS POR ACCI√ìN
        permission_map = {
            # üí∞ INVITACIONES - Requiere permisos espec√≠ficos
            "unified_send_all_invitations": [
                SystemAction.SEND_DAILY_INVITATION,
                SystemAction.SEND_WEEKLY_INVITATION, 
                SystemAction.SEND_MONTHLY_INVITATION
            ],
            
            # üé≤ SORTEOS - Requiere permisos espec√≠ficos  
            "unified_execute_all_draws": [
                SystemAction.EXECUTE_DAILY_DRAW,
                SystemAction.EXECUTE_WEEKLY_DRAW,
                SystemAction.EXECUTE_MONTHLY_DRAW
            ],
            
            # üëë GANADORES PENDIENTES - Permiso espec√≠fico
            "unified_all_pending": [SystemAction.VIEW_ALL_PENDING_WINNERS],
            
            # üõ†Ô∏è MANTENIMIENTO - Solo FULL_ADMIN
            "unified_maintenance": [SystemAction.MANAGE_ADMINS],
            
            # üìä ANALYTICS AVANZADAS - PAYMENT_SPECIALIST+
            "unified_multi_analytics": [SystemAction.VIEW_ADVANCED_STATS],
            "analytics_cross_type": [SystemAction.VIEW_ADVANCED_STATS],
            "analytics_combined": [SystemAction.VIEW_ADVANCED_STATS],
            "analytics_revenue": [SystemAction.VIEW_ADVANCED_STATS],
            "analytics_user_overlap": [SystemAction.VIEW_ADVANCED_STATS],
            "unified_combined_stats": [SystemAction.VIEW_ADVANCED_STATS],
        }
        
        # üîç VERIFICAR SOLO ACCIONES ESPEC√çFICAMENTE MAPEADAS
        for action_pattern, required_permissions in permission_map.items():
            if callback_data == action_pattern or callback_data.startswith(action_pattern):
                
                # üÜï VERIFICAR SI TIENE ALGUNO DE LOS PERMISOS REQUERIDOS
                has_any_permission = any(
                    permission_manager.has_permission(user_id, perm) 
                    for perm in required_permissions
                )
                
                if not has_any_permission:
                    admin_info = permission_manager.get_admin_info(user_id)
                    permission_level = admin_info.get('permission_group', 'Unknown') if admin_info else 'Unknown'
                    
                    # üéØ MENSAJE ESPEC√çFICO SEG√öN LA ACCI√ìN
                    required_level = "FULL_ADMIN" if action_pattern == "unified_maintenance" else "PAYMENT_SPECIALIST or higher"
                    
                    await query.edit_message_text(
                        f"‚ùå <b>Access Denied</b>\n\n"
                        f"Action: {action_pattern}\n"
                        f"Required: {required_level}\n"
                        f"Your level: {permission_level}\n\n"
                        f"üí° Contact a FULL_ADMIN for access upgrade.",
                        parse_mode='HTML'
                    )
                    return False
        
        # üü¢ PERMITIR TODAS LAS DEM√ÅS ACCIONES (paneles por tipo, refresh, etc.)
        return True


# From test_botTTT
# Callbacks de UI y pagos
async def handle_user_interface_callbacks(update, context):
    """
    üéØ SPECIFIC HANDLER: Solo callbacks de interfaz de usuario
    Maneja show_rules, user interface elements, etc.
    """
    try:
        query = update.callback_query
        await query.answer()
        
        callback_data = query.data
        
        print(f"üë§ DEBUG: User interface callback: {callback_data}")
        
        # Handle different user interface callbacks
        if callback_data == "show_rules":
            # Show complete rules using existing help function
            await show_rules_inline(query)
            
        elif callback_data.startswith("user_"):
            # Handle user-specific actions (future expansion)
            await query.edit_message_text(
                "‚ÑπÔ∏è <b>User function</b>\n\nThis user interface feature is being developed.\n\nüí° Use /help for complete information.",
                parse_mode='HTML'
            )
            
        elif callback_data.startswith("start_"):
            # Handle start menu actions (future expansion)
            await query.edit_message_text(
                "üéÅ <b>Welcome!</b>\n\nUse /start to access the main participation menu.",
                parse_mode='HTML'
            )
            
        else:
            # Fallback for unknown user interface callbacks
            await query.edit_message_text(
                "‚ÑπÔ∏è <b>Interface element</b>\n\nThis interface element is not yet implemented.\n\nüí° Use /start for main menu.",
                parse_mode='HTML'
            )
            
    except Exception as e:
        logging.error(f"Error in user interface callback: {e}")
        print(f"‚ùå DEBUG: Error in user interface callback: {e}")
        await query.edit_message_text(
            "‚ùå Error processing interface element. Please try again.",
            parse_mode='HTML'
        )

async def handle_payment_confirmations_only(integration_instance,update, context):
    """
    üéØ SPECIFIC HANDLER: Solo confirmaciones de pago
    Evita conflicto con ga_integration.py handlers
    """
    try:
        query = update.callback_query
        await query.answer()
        
        user_id = query.from_user.id
        callback_data = query.data
        
        print(f"üí∞ DEBUG: Payment confirmation callback: {callback_data} from user {user_id}")
        
        # Verify admin permissions
        config_loader = ConfigLoader()
        bot_config = config_loader.get_bot_config()
        channel_id = bot_config['channel_id']
        
        member = await context.bot.get_chat_member(channel_id, user_id)
        if member.status not in ['administrator', 'creator', 'Main Administrator']:
            await query.edit_message_text("‚ùå Only administrators can confirm payments")
            return
        
        # Process ONLY payment confirmations
        if callback_data.startswith("confirm_payment_"):
            # Parse callback: confirm_payment_<type>_<identifier>
            parts = callback_data.split("_", 3)
            if len(parts) < 4:
                print(f"‚ùå DEBUG: Invalid format - parts: {parts}")
                await query.edit_message_text("‚ùå Invalid payment callback format")
                return
            
            giveaway_type = parts[2]  # daily, weekly, monthly
            winner_identifier = parts[3]  # username or telegram_id
            
            print(f"üí∞ DEBUG: Parsed payment - Type: {giveaway_type}, Winner: {winner_identifier}")
            
            # Validate giveaway type
            if giveaway_type not in ['daily', 'weekly', 'monthly']:
                print(f"‚ùå DEBUG: Invalid giveaway type: {giveaway_type}")
                await query.edit_message_text("‚ùå Invalid giveaway type")
                return
            
            # Get giveaway system
            giveaway_system = integration_instance.get_giveaway_system(giveaway_type)
            if not giveaway_system:
                print(f"‚ùå DEBUG: Giveaway system not found for {giveaway_type}")
                await query.edit_message_text(f"‚ùå {giveaway_type.title()} system not available")
                return
            
            # ==========================================
            # üÜï ADD: Debug pending winners antes de buscar
            pending_winners = giveaway_system.get_pending_winners(giveaway_type)
            print(f"üîç DEBUG: Current {giveaway_type} pending winners: {len(pending_winners)}")
            for i, winner in enumerate(pending_winners):
                print(f"  {i+1}. ID: {winner['telegram_id']}, Username: '{winner.get('username', 'N/A')}', Status: {winner['status']}")

            # ============================================
            # Find winner using helper function
            winner_telegram_id = await integration_instance.find_winner_by_identifier(winner_identifier, giveaway_type, giveaway_system)
            
            if not winner_telegram_id:
                await query.edit_message_text(
                    f"‚ùå <b>{giveaway_type.title()} winner not found</b>\n\n"
                    f"Winner '{winner_identifier}' not found in pending {giveaway_type} winners or already processed.\n\n"
                    f"üí° The winner may have been processed already.",
                    parse_mode='HTML'
                )
                return
            
            print(f"üí∞ DEBUG: Found winner {winner_telegram_id}, confirming payment...")
            
            # üí∞ CONFIRM PAYMENT AND ANNOUNCE
            success, message = await giveaway_system.confirm_payment_and_announce(
                winner_telegram_id, user_id, giveaway_type
            )
            
            if success:
                # Get additional details for response
                prize = giveaway_system.get_prize_amount(giveaway_type)
                
                await query.edit_message_text(
                    f"‚úÖ <b>{giveaway_type.title()} Payment Confirmed Successfully</b>\n\n"
                    f"üéâ Winner: {winner_identifier}\n"
                    f"üí∞ Prize: ${prize} USD\n"
                    f"üë§ Confirmed by: {query.from_user.first_name}\n"
                    f"üìÖ Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
                    f"‚úÖ <b>Actions completed:</b>\n"
                    f"‚îú‚îÄ Winner announced in channel\n"
                    f"‚îú‚îÄ Private congratulation sent\n"
                    f"‚îú‚îÄ Payment record updated\n"
                    f"‚îî‚îÄ System ready for next {giveaway_type} draw\n\n"
                    f"üéØ <b>Status:</b> Payment process complete ‚úì",
                    parse_mode='HTML'
                )
                
                print(f"‚úÖ DEBUG: {giveaway_type.title()} payment confirmed successfully")
                
            else:
                await query.edit_message_text(
                    f"‚ùå <b>Error confirming {giveaway_type} payment</b>\n\n"
                    f"<b>Reason:</b> {message}\n\n"
                    f"üí° <b>This usually means:</b>\n"
                    f"‚Ä¢ Winner was already processed\n"
                    f"‚Ä¢ System error occurred\n"
                    f"‚Ä¢ Invalid winner state\n\n"
                    f"üîÑ Please check pending winners list or contact FULL_ADMIN if issue persists.",
                    parse_mode='HTML'
                )
                print(f"‚ùå DEBUG: Payment confirmation failed: {message}")
        
        else:
            # This shouldn't happen due to pattern filter, but safety check
            await query.edit_message_text("‚ùå Invalid payment callback")
            
    except Exception as e:
        logging.error(f"Error in payment confirmation handler: {e}")
        print(f"‚ùå DEBUG: Exception in payment confirmation: {e}")
        await query.edit_message_text(
            f"‚ùå <b>Payment confirmation system error</b>\n\n"
            f"An unexpected error occurred while processing the payment confirmation.\n\n"
            f"üí° <b>Please try:</b>\n"
            f"‚Ä¢ Use manual command: <code>/admin_confirm_payment &lt;winner&gt;</code>\n"
            f"‚Ä¢ Contact FULL_ADMIN if problem persists\n\n"
            f"<i>Error reference: {str(e)[:50]}...</i>",
            parse_mode='HTML'
        )
# Funciones helper para callbacks
async def show_rules_inline(query):
    """Show complete rules inline when requested from button"""
    try:
        # Use existing help content but format for inline display
        try:
            config_loader = ConfigLoader()
            bot_config = config_loader.get_bot_config()
            admin_username = bot_config.get('admin_username', 'admin')
        except:
            admin_username = 'admin'
        
        rules_text = f"""üÜò <b>MULTI-GIVEAWAY RULES</b>

üåü <b>AVAILABLE GIVEAWAYS:</b>

üí∞ <b>DAILY GIVEAWAY - $250 USD</b>
‚è∞ <b>Participation:</b> Monday-Friday, 1:00 AM - 4:50 PM London Time
üéØ <b>Draw:</b> Monday-Friday at 5:00 PM London Time
üîÑ <b>Cooldown:</b> 30 days after winning

üí∞ <b>WEEKLY GIVEAWAY - $500 USD</b>
‚è∞ <b>Participation:</b> Monday 9:00 AM - Friday 5:00 PM London Time
üéØ <b>Draw:</b> Friday at 5:15 PM London Time
üîÑ <b>Cooldown:</b> 60 days after winning

üí∞ <b>MONTHLY GIVEAWAY - $1000 USD</b>
‚è∞ <b>Participation:</b> Day 1 - Last Friday of month, London Time
üéØ <b>Draw:</b> Last Friday at 5:30 PM London Time
üîÑ <b>Cooldown:</b> 90 days after winning

üìã <b>REQUIREMENTS FOR ALL GIVEAWAYS:</b>
‚úÖ Be a member of this channel
‚úÖ Active MT5 LIVE account (not demo)
‚úÖ Minimum balance of $100 USD
‚úÖ One participation per giveaway type per period

üîí <b>IMPORTANT RULES:</b>
‚Ä¢ Each MT5 account belongs to the first user who registers it
‚Ä¢ You can participate in ALL giveaway types simultaneously
‚Ä¢ Independent cooldowns for each giveaway type
‚Ä¢ Must confirm receipt of prize if you win

üìû <b>NEED HELP?</b>
Contact administrator: @{admin_username}

‚è∞ <b>CURRENT LONDON TIME:</b>
{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC"""

        # Add back button
        keyboard = [[InlineKeyboardButton("üîô Back to Start", callback_data="start_main")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            rules_text, 
            parse_mode='HTML',
            reply_markup=reply_markup
        )
        
    except Exception as e:
        logging.error(f"Error showing rules inline: {e}")
        await query.edit_message_text(
            "‚ùå Error loading rules. Use /help for complete information.",
            parse_mode='HTML'
        )



        
